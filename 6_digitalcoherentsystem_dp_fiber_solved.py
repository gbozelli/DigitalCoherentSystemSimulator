# -*- coding: utf-8 -*-
"""6_DigitalCoherentSystem_DP_fiber_solved.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/120eO2wUnIRLB09moO0Dr9X54yWaz6gin

# 6. Simulation of a dual-polarization digital coherent system

In this notebook, you will simulate a complete communication system employing QAM modulation formats with dual polarization.

In particular you will learn some important concepts, including:
- QAM modulation and demodulation
- Time synchronization through correlation
- Phase alignment
- Filtering

The simulation includes lasers, modulators, and photodetectors.

## 6.0 Reset the variables and configure the environment:
"""

# Commented out IPython magic to ensure Python compatibility.
#%reset
import numpy as np
import numpy.matlib as ml
import matplotlib.pyplot as plt
from scipy import signal
# %matplotlib qt

"""## 6.1 Function declaration

### 6.1.1 Modulation, demodulation, and coding
"""

# QAM_mod: QAM modulator for values of M of 4, 8, 16, and 32
def QAM_mod(s,M):

    # Preliminary calculations
    N_bits = int(np.log2(M))
    N_sym = int(len(s)/N_bits)
    s_I = np.zeros(N_sym,dtype=int)
    s_Q = np.zeros(N_sym,dtype=int)

    # N_bits = 1, M = 2
    if N_bits == 1:
        s_1 = np.reshape(s,[N_sym,N_bits])
        for ind_sym in range(N_sym):
            if s_1[ind_sym,:]==0:
                s_I[ind_sym], s_Q[ind_sym] = 0,1
            elif s_1[ind_sym,:]==1:
                s_I[ind_sym], s_Q[ind_sym] = 0,-1

    # N_bits = 2, M = 4
    if N_bits == 2:
        s_1 = np.reshape(s,[N_sym,N_bits])
        for ind_sym in range(N_sym):
            if all(s_1[ind_sym,:]==[0,1]):
                s_I[ind_sym], s_Q[ind_sym] = -1,1
            elif all(s_1[ind_sym,:]==[0,0]):
                s_I[ind_sym], s_Q[ind_sym] = 1,1
            elif all(s_1[ind_sym,:]==[1,1]):
                s_I[ind_sym], s_Q[ind_sym] = -1,-1
            elif all(s_1[ind_sym,:]==[1,0]):
                s_I[ind_sym], s_Q[ind_sym] = 1,-1

    # N_bits = 3, M = 8
    if N_bits == 3:
        s_1 = np.reshape(s,[N_sym,N_bits])
        for ind_sym in range(N_sym):
            if all(s_1[ind_sym,:]==[0,0,0]):
                s_I[ind_sym], s_Q[ind_sym] = -3,1
            elif all(s_1[ind_sym,:]==[0,1,0]):
                s_I[ind_sym], s_Q[ind_sym] = -1,1
            elif all(s_1[ind_sym,:]==[1,1,0]):
                s_I[ind_sym], s_Q[ind_sym] = 1,1
            elif all(s_1[ind_sym,:]==[1,0,0]):
                s_I[ind_sym], s_Q[ind_sym] = 3,1
            elif all(s_1[ind_sym,:]==[0,0,1]):
                s_I[ind_sym], s_Q[ind_sym] = -3,-1
            elif all(s_1[ind_sym,:]==[0,1,1]):
                s_I[ind_sym], s_Q[ind_sym] = -1,-1
            elif all(s_1[ind_sym,:]==[1,1,1]):
                s_I[ind_sym], s_Q[ind_sym] = 1,-1
            elif all(s_1[ind_sym,:]==[1,0,1]):
                s_I[ind_sym], s_Q[ind_sym] = 3,-1

    # N_bits = 4, M = 16
    if N_bits == 4:
        s_1 = np.reshape(s,[N_sym,N_bits])
        for ind_sym in range(N_sym):
            if all(s_1[ind_sym,:]==[0,0,1,0]):
                s_I[ind_sym], s_Q[ind_sym] = -3,3
            elif all(s_1[ind_sym,:]==[0,1,1,0]):
                s_I[ind_sym], s_Q[ind_sym] = -1,3
            elif all(s_1[ind_sym,:]==[1,1,1,0]):
                s_I[ind_sym], s_Q[ind_sym] = 1,3
            elif all(s_1[ind_sym,:]==[1,0,1,0]):
                s_I[ind_sym], s_Q[ind_sym] = 3,3
            elif all(s_1[ind_sym,:]==[0,0,1,1]):
                s_I[ind_sym], s_Q[ind_sym] = -3,1
            elif all(s_1[ind_sym,:]==[0,1,1,1]):
                s_I[ind_sym], s_Q[ind_sym] = -1,1
            elif all(s_1[ind_sym,:]==[1,1,1,1]):
                s_I[ind_sym], s_Q[ind_sym] = 1,1
            elif all(s_1[ind_sym,:]==[1,0,1,1]):
                s_I[ind_sym], s_Q[ind_sym] = 3,1
            elif all(s_1[ind_sym,:]==[0,0,0,1]):
                s_I[ind_sym], s_Q[ind_sym] = -3,-1
            elif all(s_1[ind_sym,:]==[0,1,0,1]):
                s_I[ind_sym], s_Q[ind_sym] = -1,-1
            elif all(s_1[ind_sym,:]==[1,1,0,1]):
                s_I[ind_sym], s_Q[ind_sym] = 1,-1,
            elif all(s_1[ind_sym,:]==[1,0,0,1]):
                s_I[ind_sym], s_Q[ind_sym] = 3,-1
            elif all(s_1[ind_sym,:]==[0,0,0,0]):
                s_I[ind_sym], s_Q[ind_sym] = -3,-3
            elif all(s_1[ind_sym,:]==[0,1,0,0]):
                s_I[ind_sym], s_Q[ind_sym] = -1,-3
            elif all(s_1[ind_sym,:]==[1,1,0,0]):
                s_I[ind_sym], s_Q[ind_sym] = 1,-3
            elif all(s_1[ind_sym,:]==[1,0,0,0]):
                s_I[ind_sym], s_Q[ind_sym] = 3,-3

    # N_bits = 5, M = 32
    if N_bits == 5:
        s_1 = np.reshape(s,[N_sym,N_bits])
        for ind_sym in range(N_sym):
            if all(s_1[ind_sym,:]==[1,0,1,0,0]):
                s_I[ind_sym], s_Q[ind_sym] = -3,5
            elif all(s_1[ind_sym,:]==[1,0,1,1,0]):
                s_I[ind_sym], s_Q[ind_sym] = -1,5
            elif all(s_1[ind_sym,:]==[1,1,1,1,0]):
                s_I[ind_sym], s_Q[ind_sym] = 1,5
            elif all(s_1[ind_sym,:]==[1,1,1,0,0]):
                s_I[ind_sym], s_Q[ind_sym] = 3,5
            elif all(s_1[ind_sym,:]==[1,0,1,1,1]):
                s_I[ind_sym], s_Q[ind_sym] = -5,3
            elif all(s_1[ind_sym,:]==[0,0,1,1,1]):
                s_I[ind_sym], s_Q[ind_sym] = -3,3
            elif all(s_1[ind_sym,:]==[0,0,1,1,0]):
                s_I[ind_sym], s_Q[ind_sym] = -1,3
            elif all(s_1[ind_sym,:]==[0,1,1,1,0]):
                s_I[ind_sym], s_Q[ind_sym] = 1,3
            elif all(s_1[ind_sym,:]==[0,1,1,1,1]):
                s_I[ind_sym], s_Q[ind_sym] = 3,3
            elif all(s_1[ind_sym,:]==[1,1,1,1,1]):
                s_I[ind_sym], s_Q[ind_sym] = 5,3
            elif all(s_1[ind_sym,:]==[1,0,1,0,1]):
                s_I[ind_sym], s_Q[ind_sym] = -5,1
            elif all(s_1[ind_sym,:]==[0,0,1,0,1]):
                s_I[ind_sym], s_Q[ind_sym] = -3,1
            elif all(s_1[ind_sym,:]==[0,0,1,0,0]):
                s_I[ind_sym], s_Q[ind_sym] = -1,1
            elif all(s_1[ind_sym,:]==[0,1,1,0,0]):
                s_I[ind_sym], s_Q[ind_sym] = 1,1
            elif all(s_1[ind_sym,:]==[0,1,1,0,1]):
                s_I[ind_sym], s_Q[ind_sym] = 3,1
            elif all(s_1[ind_sym,:]==[1,1,1,0,1]):
                s_I[ind_sym], s_Q[ind_sym] = 5,1
            elif all(s_1[ind_sym,:]==[1,0,0,0,1]):
                s_I[ind_sym], s_Q[ind_sym] = -5,-1
            elif all(s_1[ind_sym,:]==[0,0,0,0,1]):
                s_I[ind_sym], s_Q[ind_sym] = -3,-1
            elif all(s_1[ind_sym,:]==[0,0,0,0,0]):
                s_I[ind_sym], s_Q[ind_sym] = -1,-1
            elif all(s_1[ind_sym,:]==[0,1,0,0,0]):
                s_I[ind_sym], s_Q[ind_sym] = 1,-1
            elif all(s_1[ind_sym,:]==[0,1,0,0,1]):
                s_I[ind_sym], s_Q[ind_sym] = 3,-1,
            elif all(s_1[ind_sym,:]==[1,1,0,0,1]):
                s_I[ind_sym], s_Q[ind_sym] = 5,-1
            elif all(s_1[ind_sym,:]==[1,0,0,1,1]):
                s_I[ind_sym], s_Q[ind_sym] = -5,-3
            elif all(s_1[ind_sym,:]==[0,0,0,1,1]):
                s_I[ind_sym], s_Q[ind_sym] = -3,-3,
            elif all(s_1[ind_sym,:]==[0,0,0,1,0]):
                s_I[ind_sym], s_Q[ind_sym] = -1,-3
            elif all(s_1[ind_sym,:]==[0,1,0,1,0]):
                s_I[ind_sym], s_Q[ind_sym] = 1,-3,
            elif all(s_1[ind_sym,:]==[0,1,0,1,1]):
                s_I[ind_sym], s_Q[ind_sym] = 3,-3
            elif all(s_1[ind_sym,:]==[1,1,0,1,1]):
                s_I[ind_sym], s_Q[ind_sym] = 5,-3
            elif all(s_1[ind_sym,:]==[1,0,0,0,0]):
                s_I[ind_sym], s_Q[ind_sym] = -3,-5
            elif all(s_1[ind_sym,:]==[1,0,0,1,0]):
                s_I[ind_sym], s_Q[ind_sym] = -1,-5,
            elif all(s_1[ind_sym,:]==[1,1,0,1,0]):
                s_I[ind_sym], s_Q[ind_sym] = 1,-5
            elif all(s_1[ind_sym,:]==[1,1,0,0,0]):
                s_I[ind_sym], s_Q[ind_sym] = 3,-5
    return s_I+1j*s_Q

# QAM_dem: QAM demodulator for values of M of 4, 8, 16, and 32
def QAM_dem(s,M):
    # Preliminary calculations
    N_bits = int(np.log2(M))
    N_sym = len(s)
    N_bits_total = N_bits*N_sym
    sb = np.zeros(N_bits_total,dtype=int)
    sd = np.zeros(N_sym)

    if N_bits == 2:
        # Find the closest constellation point
        const_points = np.array([-1+1j,1+1j,\
                                -1-1j,1-1j])
        sc_ext = ml.repmat(s,M,1)

        const_points_ext = np.transpose(ml.repmat(const_points,N_sym,1))

        #print(np.shape(sc_ext))
        #print(np.shape(sc_ext))
        sym_dist = np.abs(sc_ext-const_points_ext)
        min_dist = np.min(sym_dist,axis=0)
        #print(sc_ext)
        #print(const_points_ext)
        #print(sym_dist)

        ind_array = np.zeros(N_sym)
        for ind_sym in range(N_sym):
            ind = np.where(min_dist[ind_sym]==sym_dist[:,ind_sym])
            if ind[0][0] == 0:
                sb_aux = np.array([0,1])
            elif ind[0][0] == 1:
                sb_aux = np.array([0,0])
            elif ind[0][0] == 2:
                sb_aux = np.array([1,1])
            elif ind[0][0] == 3:
                sb_aux = np.array([1,0])
            ind_i = ind_sym*N_bits
            ind_f = (ind_sym+1)*N_bits
            sb[ind_i:ind_f] = sb_aux
            sd[ind_sym]=min_dist[ind_sym]

    if N_bits == 3:
        # Find the closest constellation point
        const_points = np.array([-3+1j,-1+1j,1+1j,3+1j,\
                                -3-1j,-1-1j,1-1j,3-1j])
        sc_ext = ml.repmat(s,M,1)

        const_points_ext = np.transpose(ml.repmat(const_points,N_sym,1))

        #print(np.shape(sc_ext))
        #print(np.shape(sc_ext))
        sym_dist = np.abs(sc_ext-const_points_ext)
        min_dist = np.min(sym_dist,axis=0)
        #print(sc_ext)
        #print(const_points_ext)
        #print(sym_dist)

        ind_array = np.zeros(N_sym)
        for ind_sym in range(N_sym):
            ind = np.where(min_dist[ind_sym]==sym_dist[:,ind_sym])
            if ind[0][0] == 0:
                sb_aux = np.array([0,0,0])
            elif ind[0][0] == 1:
                sb_aux = np.array([0,1,0])
            elif ind[0][0] == 2:
                sb_aux = np.array([1,1,0])
            elif ind[0][0] == 3:
                sb_aux = np.array([1,0,0])
            elif ind[0][0] == 4:
                sb_aux = np.array([0,0,1])
            elif ind[0][0] == 5:
                sb_aux = np.array([0,1,1])
            elif ind[0][0] == 6:
                sb_aux = np.array([1,1,1])
            elif ind[0][0] == 7:
                sb_aux = np.array([1,0,1])

            ind_i = ind_sym*N_bits
            ind_f = (ind_sym+1)*N_bits
            sb[ind_i:ind_f] = sb_aux
            sd[ind_sym]=min_dist[ind_sym]

    if N_bits == 4:
        # Find the closest constellation point
        const_points = np.array([-3+3j,-1+3j,1+3j,3+3j,\
                                -3+1j,-1+1j,1+1j,3+1j,\
                                -3-1j,-1-1j,1-1j,3-1j,\
                                -3-3j,-1-3j,1-3j,3-3j])
        sc_ext = ml.repmat(s,M,1)
        const_points_ext = np.transpose(ml.repmat(const_points,N_sym,1))
        sym_dist = np.abs(sc_ext-const_points_ext)
        min_dist = np.min(sym_dist,axis=0)
        #print(sc_ext)
        #print(const_points_ext)
        #print(sym_dist)
        #print(min_dist)
        ind_array = np.zeros(N_sym)
        for ind_sym in range(N_sym):
            #print(min_dist[ind_sym])
            #print(sym_dist[:,ind_sym])
            ind = np.where(min_dist[ind_sym]==sym_dist[:,ind_sym])
            #print(ind[0][0])
            #ind_array[ind_sym] = ind[0][0]
            if ind[0][0] == 0:
                sb_aux = np.array([0,0,1,0])
            elif ind[0][0] == 1:
                sb_aux = np.array([0,1,1,0])
            elif ind[0][0] == 2:
                sb_aux = np.array([1,1,1,0])
            elif ind[0][0] == 3:
                sb_aux = np.array([1,0,1,0])
            elif ind[0][0] == 4:
                sb_aux = np.array([0,0,1,1])
            elif ind[0][0] == 5:
                sb_aux = np.array([0,1,1,1])
            elif ind[0][0] == 6:
                sb_aux = np.array([1,1,1,1])
            elif ind[0][0] == 7:
                sb_aux = np.array([1,0,1,1])
            elif ind[0][0] == 8:
                sb_aux = np.array([0,0,0,1])
            elif ind[0][0] == 9:
                sb_aux = np.array([0,1,0,1])
            elif ind[0][0] == 10:
                sb_aux = np.array([1,1,0,1])
            elif ind[0][0] == 11:
                sb_aux = np.array([1,0,0,1])
            elif ind[0][0] == 12:
                sb_aux = np.array([0,0,0,0])
            elif ind[0][0] == 13:
                sb_aux = np.array([0,1,0,0])
            elif ind[0][0] == 14:
                sb_aux = np.array([1,1,0,0])
            elif ind[0][0] == 15:
                sb_aux = np.array([1,0,0,0])

            ind_i = ind_sym*N_bits
            ind_f = (ind_sym+1)*N_bits
            sb[ind_i:ind_f] = sb_aux
            sd[ind_sym]=min_dist[ind_sym]

    if N_bits == 5:
        # Find the closest constellation point
        const_points = np.array([-3+5j,-1+5j,1+5j,3+5j,\
                                -5+3j,-3+3j,-1+3j,1+3j,3+3j,5+3j,\
                                -5+1j,-3+1j,-1+1j,1+1j,3+1j,5+1j,\
                                -5-1j,-3-1j,-1-1j,1-1j,3-1j,5-1j,\
                                -5-3j,-3-3j,-1-3j,1-3j,3-3j,5-3j,\
                                -3-5j,-1-5j,1-5j,3-5j])
        sc_ext = ml.repmat(s,M,1)
        const_points_ext = np.transpose(ml.repmat(const_points,N_sym,1))
        sym_dist = np.abs(sc_ext-const_points_ext)
        min_dist = np.min(sym_dist,axis=0)
        #print(sc_ext)
        #print(const_points_ext)
        #print(sym_dist)
        #print(min_dist)
        ind_array = np.zeros(N_sym)
        for ind_sym in range(N_sym):
            #print(min_dist[ind_sym])
            #print(sym_dist[:,ind_sym])
            ind = np.where(min_dist[ind_sym]==sym_dist[:,ind_sym])
            #print(ind[0][0])
            #ind_array[ind_sym] = ind[0][0]
            if ind[0][0] == 0:
                sb_aux = np.array([1,0,1,0,0])
            elif ind[0][0] == 1:
                sb_aux = np.array([1,0,1,1,0])
            elif ind[0][0] == 2:
                sb_aux = np.array([1,1,1,1,0])
            elif ind[0][0] == 3:
                sb_aux = np.array([1,1,1,0,0])
            elif ind[0][0] == 4:
                sb_aux = np.array([1,0,1,1,1])
            elif ind[0][0] == 5:
                sb_aux = np.array([0,0,1,1,1])
            elif ind[0][0] == 6:
                sb_aux = np.array([0,0,1,1,0])
            elif ind[0][0] == 7:
                sb_aux = np.array([0,1,1,1,0])
            elif ind[0][0] == 8:
                sb_aux = np.array([0,1,1,1,1])
            elif ind[0][0] == 9:
                sb_aux = np.array([1,1,1,1,1])
            elif ind[0][0] == 10:
                sb_aux = np.array([1,0,1,0,1])
            elif ind[0][0] == 11:
                sb_aux = np.array([0,0,1,0,1])
            elif ind[0][0] == 12:
                sb_aux = np.array([0,0,1,0,0])
            elif ind[0][0] == 13:
                sb_aux = np.array([0,1,1,0,0])
            elif ind[0][0] == 14:
                sb_aux = np.array([0,1,1,0,1])
            elif ind[0][0] == 15:
                sb_aux = np.array([1,1,1,0,1])
            elif ind[0][0] == 16:
                sb_aux = np.array([1,0,0,0,1])
            elif ind[0][0] == 17:
                sb_aux = np.array([0,0,0,0,1])
            elif ind[0][0] == 18:
                sb_aux = np.array([0,0,0,0,0])
            elif ind[0][0] == 19:
                sb_aux = np.array([0,1,0,0,0])
            elif ind[0][0] == 20:
                sb_aux = np.array([0,1,0,0,1])
            elif ind[0][0] == 21:
                sb_aux = np.array([1,1,0,0,1])
            elif ind[0][0] == 22:
                sb_aux = np.array([1,0,0,1,1])
            elif ind[0][0] == 23:
                sb_aux = np.array([0,0,0,1,1])
            elif ind[0][0] == 24:
                sb_aux = np.array([0,0,0,1,0])
            elif ind[0][0] == 25:
                sb_aux = np.array([0,1,0,1,0])
            elif ind[0][0] == 26:
                sb_aux = np.array([0,1,0,1,1])
            elif ind[0][0] == 27:
                sb_aux = np.array([1,1,0,1,1])
            elif ind[0][0] == 28:
                sb_aux = np.array([1,0,0,0,0])
            elif ind[0][0] == 29:
                sb_aux = np.array([1,0,0,1,0])
            elif ind[0][0] == 30:
                sb_aux = np.array([1,1,0,1,0])
            elif ind[0][0] == 31:
                sb_aux = np.array([1,1,0,0,0])

            ind_i = ind_sym*N_bits
            ind_f = (ind_sym+1)*N_bits
            sb[ind_i:ind_f] = sb_aux
            sd[ind_sym]=min_dist[ind_sym]

    return [sb,sd]

# DAC_Nyquist: DAC considering Nyquist filtering
def DAC_Nyquist(s=None,SpS=16,RollOff=0.2,plot_flag=False):

    # Initial calculations
    N_sym = len(s)
    N_samples = N_sym*SpS

    # Conversion to the frequency domain
    S = np.fft.fftshift(np.fft.fft(s))
    S_os = np.zeros(N_samples,dtype=complex)

    # Ideal interpolation (Nyquist limit)
    ind_i = int(N_samples/2-N_sym/2)
    ind_f = ind_i+N_sym
    S_os[ind_i:ind_f] = S
    s_os = SpS*np.fft.ifft(np.fft.ifftshift(S_os))
    S_nyq = np.zeros(N_samples,dtype=complex)
    ind_i = int(N_samples/2-N_sym-N_sym/2)
    ind_f = ind_i+N_sym
    S_nyq[ind_i:ind_f] = S
    ind_i = int(N_samples/2-N_sym/2)
    ind_f = ind_i+N_sym
    S_nyq[ind_i:ind_f] = S
    ind_i = int(N_samples/2+N_sym-N_sym/2)
    ind_f = ind_i+N_sym
    S_nyq[ind_i:ind_f] = S

    ind = np.arange(N_samples)
    N_aux = int(RollOff*N_sym)
    ind_aux = np.arange(int(N_aux))
    s_aux_1 = 0.5*(1-np.cos(np.pi*ind_aux/N_aux))
    s_aux_2 = 0.5*(1+np.cos(np.pi*ind_aux/N_aux))
    window = np.zeros(N_samples)
    ind_i_1 = int(N_samples/2-N_sym/2-N_aux/2)
    ind_f_1 = ind_i_1+int(N_aux)
    window[ind_i_1:ind_f_1] = s_aux_1
    ind_i_2 = int(N_samples/2+N_sym/2-N_aux/2)
    ind_f_2 = ind_i_2+int(N_aux)
    window[ind_i_2:ind_f_2] = s_aux_2
    window[ind_f_1:ind_i_2] = np.ones(ind_i_2-ind_f_1)

    if plot_flag:
        plt.figure()
        plt.plot(np.abs(S_nyq)/max(np.abs(S_nyq)))
        plt.plot(np.abs(window)/max(window))

    S_nyq = window*S_nyq
    s_nyq = SpS*np.fft.ifft(np.fft.ifftshift(S_nyq))

    return s_nyq

# QAM transmitter
def QAM_transmitter(N_sync=128,sync_seed=0,\
                    N_MIMO=32,MIMO_i=0,\
                    N_inf=1024,M=16,SpS=16,RollOff=0.2,ts=1e-12,
                    N_zeros_init=20,N_zeros_final=20,plot_flag=True):

    ## Sequence generation

    # Initial zeros
    s_zeros_init = np.zeros(N_zeros_init)
    # Syncronization sequence
    np.random.seed(sync_seed)
    s_sync_i = np.random.randint(0,2,N_sync,dtype=int)*2-1
    # MIMO sequence
    #print(MIMO_i)
    if MIMO_i == 1:
        s_MIMO_i = np.append(np.zeros(int(N_MIMO/2)),np.ones(int(N_MIMO/2)))
    else:
        s_MIMO_i = np.append(np.ones(int(N_MIMO/2)),np.zeros(int(N_MIMO/2)))
    s_MIMO_i = s_MIMO_i*np.mod(np.arange(N_MIMO)+MIMO_i,2)
    #print(s_MIMO_i)

    # Information sequence
    N_bits = int(np.log2(M))
    N_bits_total = int(N_bits*N_inf)
    s_b = np.random.randint(0,2,N_bits_total,dtype=int)
    s_inf = QAM_mod(s_b,M)
    s_inf = s_inf/np.max(np.real(s_inf))

    # Final zeros
    s_zeros_final = np.zeros(N_zeros_final)

    # Concatenate
    s = np.concatenate([s_zeros_init,s_sync_i,s_inf,s_zeros_final])

    ## Conversion to the continuous time
    s_cont = DAC_Nyquist(s=s,SpS=SpS,RollOff=RollOff)

    ind = np.arange(len(s))*SpS

    t = ts*(np.arange(len(s_cont)))

    if plot_flag:
        plt.figure()
        plt.plot(t*1e9,np.real(s_cont))
        plt.plot(ind*ts*1e9,np.real(s),'.')
        plt.xlabel('Time [ns]')
        plt.ylabel('In-phase component [a.u.]')
        plt.xlim([0,np.max(t)*1e9])

        plt.figure()
        plt.plot(np.real(s_cont),np.imag(s_cont),alpha=0.2)
        plt.plot(np.real(s),np.imag(s),'.')
        plt.xlabel('In-phase')
        plt.ylabel('Quadrature')
        plt.axis('square')

    return [s_cont,t,s_b]


def QAM_receiver(s,M,N_sync=128,N_inf=4096,SpS=16,RollOff=0.2,sync_seed=0,ts=1e-12,plot_flag=False,s_b=None):
    s_in = s

    # Generation of time vector
    N_samples = len(s)
    t = ts*(np.arange(N_samples))
    fs = 1/ts
    f = (np.arange(N_samples)/N_samples)*fs-fs/2

    # Coarse frequency offset compensation

    N_samples = len(s)
    N_sym = int(N_samples/SpS)
    S_nyq = np.zeros(N_samples,dtype=complex)
    ind_i = int(N_samples/2-N_sym/2)
    ind_f = int(ind_i+N_sym)
    window = np.zeros(N_samples)
    window[ind_i:ind_f] = np.ones(ind_f-ind_i)

    f_min, f_max, N_f = -500e6,500e6,101
    f_offset_array = np.linspace(f_min,f_max,N_f)
    P_array = np.linspace(f_min,f_max,N_f)

    for counter, offset in enumerate(f_offset_array):
        s_shift = np.exp(1j*2*np.pi*offset*t)*s
        S_shift = np.abs(np.fft.fftshift(np.fft.fft(s_shift)))
        S_f = S_shift*window
        P_array[counter] = sum(np.abs(S_f)**2)

    max_offset_opt = max(P_array)
    ind_offset_opt = np.where(P_array==max_offset_opt)
    f_offset_opt = f_offset_array[ind_offset_opt[0][0]]

    # Refining
    p = np.polyfit(f_offset_array,P_array,4)
    N_f = 2001
    f_offset_array_ext = np.linspace(f_min,f_max,N_f)
    P_array_ext = np.polyval(p,f_offset_array_ext)
    if plot_flag:
        plt.figure()
        plt.plot(f_offset_array/1e6,P_array,'o')
        plt.plot(f_offset_array_ext/1e6,P_array_ext)
        plt.ylabel('Power [a.u.]')
        plt.xlabel('Frequency offset [MHz]')

    max_offset_opt = max(P_array_ext)
    ind_offset_opt = np.where(P_array_ext==max_offset_opt)
    f_offset_opt = f_offset_array_ext[ind_offset_opt[0][0]]

    #f_offset_opt = 0
    s = np.exp(1j*2*np.pi*f_offset_opt*t)*s

    #s = s_in

    # Filter the signal using a Nyquist filter
    N_samples = len(s)
    N_sym = int(N_samples/SpS)
    S_nyq = np.zeros(N_samples,dtype=complex)
    ind_i = int(N_samples/2-N_sym-N_sym/2)
    ind_f = ind_i+N_sym

    ind = np.arange(N_samples)
    N_aux = int(RollOff*N_sym)
    ind_aux = np.arange(int(N_aux))
    s_aux_1 = 1*np.ones(N_aux)   #0.5*(1-np.cos(np.pi*ind_aux/N_aux))
    s_aux_2 = 1*np.ones(N_aux)   #0.5*(1+np.cos(np.pi*ind_aux/N_aux))
    window = np.zeros(N_samples)
    ind_i_1 = int(N_samples/2-N_sym/2-N_aux/2)
    ind_f_1 = ind_i_1+int(N_aux)
    window[ind_i_1:ind_f_1] = s_aux_1
    ind_i_2 = int(N_samples/2+N_sym/2-N_aux/2)
    ind_f_2 = ind_i_2+int(N_aux)
    window[ind_i_2:ind_f_2] = s_aux_2
    window[ind_f_1:ind_i_2] = np.ones(ind_i_2-ind_f_1)
    S = np.fft.fftshift(np.fft.fft(s))
    S_f = S*window
    s_f = SpS*np.fft.ifft(np.fft.ifftshift(S_f))
    s = s_f
    #s = s_in

    if plot_flag:
        plt.figure()
        plt.plot(f/1e9,20*np.log10(np.abs(S)/max(np.abs(S))),label='signal')
        plt.plot(f/1e9,20*np.log10(window/max(np.abs(window))),label='filter')
        plt.ylabel('Normalized power / Filter resp. [dB]')
        plt.xlabel('Frequency [GHz]')

    # Generation of the sync sequence
    # Initial zeros
    s_zeros_init = np.zeros(10,dtype=complex)
    # Sync sequence
    np.random.seed(sync_seed)
    s_sync_i = np.random.randint(0,2,N_sync,dtype=int)*2-1
    # Final zeros
    s_zeros_final = np.zeros(10,dtype=complex)
    s_b_i = np.concatenate([s_zeros_init,s_sync_i,s_zeros_final])
    # Digital-to-analogue conversion of the synchronization sequence
    s_sync_i = DAC_Nyquist(s=s_b_i,SpS=SpS,RollOff=RollOff)

    # Correlation between signal and synchronization
    s_xx_i = np.correlate(s,s_sync_i)
    if plot_flag:
        plt.figure()
        plt.plot(abs(s_xx_i))
        plt.ylabel('Cross-correlation')
        plt.xlabel('Sample index')
        plt.xlim([0,len(s_xx_i)])

    # Generating the index of the maximum correlation
    max_i = np.max(np.abs(s_xx_i))
    ind_i = np.where(max_i==np.abs(s_xx_i))
    # Finding the inidices of the sync and information
    ind_sync = (np.arange(N_sync)+10)*SpS+ind_i[0][0]
    ind_inf = (np.arange(N_inf)+10+N_sync)*SpS+ind_i[0][0]
    # Sampling the signal
    s_sync = s[ind_sync]
    s_inf = s[ind_inf]

    if plot_flag:
        # In-phase component time domain
        plt.figure()
        plt.plot(t*1e9,np.real(s))
        plt.plot(ind_sync*ts*1e9,np.real(s_sync),'.')
        plt.plot(ind_inf*ts*1e9,np.real(s_inf),'.')
        plt.xlabel('Time [ns]')
        plt.ylabel('In-phase component [a.u.]')
        plt.title('Raw data')
        plt.xlim([0,np.max(t)*1e9])

        # Contellation
        plt.figure()
        plt.plot(np.real(s_inf),np.imag(s_inf),'.')
        plt.plot(np.real(s_sync),np.imag(s_sync),'.')
        plt.axis('square')
        plt.xlabel('In-phase [a.u.]')
        plt.ylabel('Quadrature [a.u.]')
        plt.title('Raw data')

    # Finding the rotation angle
    theta_hat = np.angle(s_xx_i[ind_i])
    s = s*np.exp(-1j*theta_hat)
    s_sync = s_sync*np.exp(-1j*theta_hat)
    s_inf = s_inf*np.exp(-1j*theta_hat)

    if plot_flag:
        # In-phase component time domain
        plt.figure()
        plt.plot(t*1e9,np.real(s))
        plt.plot(ind_sync*ts*1e9,np.real(s_sync),'.')
        plt.plot(ind_inf*ts*1e9,np.real(s_inf),'.')
        plt.xlabel('Time [ns]')
        plt.ylabel('In-phase component [a.u.]')
        plt.title('After phase rotation')
        plt.xlim([0,np.max(t)*1e9])

        # Contellation
        plt.figure()
        plt.plot(np.real(s_inf),np.imag(s_inf),'.')
        plt.plot(np.real(s_sync),np.imag(s_sync),'.')
        plt.axis('square')
        plt.xlabel('In-phase [a.u.]')
        plt.ylabel('Quadrature [a.u.]')
        plt.title('After phase rotation')

    # Finding the scaling factor
    K = max_i/1940
    s = s/K
    s_sync = s_sync/K
    s_inf = s_inf/K
    if plot_flag:
        # In-phase component time domain
        plt.figure()
        plt.plot(t*1e9,np.real(s))
        plt.plot(ind_sync*ts*1e9,np.real(s_sync),'.')
        plt.plot(ind_inf*ts*1e9,np.real(s_inf),'.')
        plt.xlabel('Time [ns]')
        plt.ylabel('In-phase component [a.u.]')
        plt.title('After scaling correction')
        plt.xlim([0,np.max(t)*1e9])

        # Contellation
        plt.figure()
        plt.plot(np.real(s_inf),np.imag(s_inf),'.')
        plt.plot(np.real(s_sync),np.imag(s_sync),'.')
        plt.axis('square')
        plt.xlabel('In-phase [a.u.]')
        plt.ylabel('Quadrature [a.u.]')
        plt.title('After scaling correction')

    # Desnormalized the amplitude of the modulated signal
    if M == 16:
        s_inf_dn = 3*s_inf
    if M == 32:
        s_inf_dn = 5*s_inf

    # Blind phase noise and residual frequency offset compensation
    N_block = 16
    N_overlap = 8

    ind_1 = 0
    ind_2 = ind_1+N_block
    phi = 0
    min_dphi = -np.pi/4
    max_dphi = np.pi/4
    N_dphi = 21
    dphi_array = np.linspace(min_dphi,max_dphi,N_dphi)

    phi_array = np.array([0])
    ind_array = np.array([0])
    counter1 = 0
    while ind_2<=len(s_inf_dn):
        s_block = s_inf_dn[ind_1:ind_2]
        d_array_block = np.zeros(N_dphi)
        for counter, dphi in enumerate(dphi_array):
            s_block_rot = s_block*np.exp(1j*(dphi+phi))
            s_hat, dist = QAM_dem(s_block_rot,M)
            d_array_block[counter] = np.var(dist)

        #plt.figure()
        #plt.plot(d_array_block)

        d_min = min(d_array_block)
        ind_min = np.where(d_array_block==d_min)
        dphi_opt = dphi_array[ind_min[0][0]]
        phi = phi+dphi_opt
        counter1 += 1
        phi_array = np.append(phi_array, phi)
        ind_array = np.append(ind_array, int((ind_2+ind_1)/2))
        ind_1 = ind_1+N_block-N_overlap
        ind_2 = ind_1+N_block

    ind_array = np.concatenate(([0],ind_array,[len(s_inf_dn)]))
    phi_array = np.concatenate(([0],phi_array,[phi_array[-1]]))
    phi_interp = np.interp(np.arange(len(s_inf_dn)),ind_array,phi_array)

    if plot_flag:
        plt.figure()
        plt.plot(phi_interp)
        #print(len(phi_interp))
    s_inf_pc = s_inf_dn*np.exp(1j*phi_interp)

    if plot_flag:
        # Contellation
        plt.figure()
        plt.plot(np.real(s_inf_pc),np.imag(s_inf_pc),'.')
        plt.axis('square')
        plt.xlabel('In-phase [a.u.]')
        plt.ylabel('Quadrature [a.u.]')
        plt.title('After scaling correction')

    #f plot_flag:
    #   constellation_analysis(s_inf_pc)
    #constellation_analysis(s_inf_pc)

    # Demapping
    s_hat, dist = QAM_dem(s_inf_pc,M)

    if plot_flag:
        plt.figure()
        plt.stem(s_hat!=s_b)

    BER = np.mean(s_hat!=s_b)

    return [s_inf, s_sync, s_inf_dn, BER]

# Dual polarization receiver
def QAM_receiver_DP(s,M,N_sync=128,N_inf=4096,SpS=16,RollOff=0.2,sync_seed=0,ts=1e-12,plot_flag=False,s_b=None):
    s_in = s
    s_x = s[0,:]
    s_y = s[1,:]

    # Generation of time vector
    N_samples = len(s)
    t = ts*(np.arange(N_samples))
    fs = 1/ts
    f = (np.arange(N_samples)/N_samples)*fs-fs/2

    # Coarse frequency offset compensation
    N_samples = len(s_x)
    N_sym = int(N_samples/SpS)
    S_nyq = np.zeros(N_samples,dtype=complex)
    ind_i = int(N_samples/2-N_sym/2)
    ind_f = int(ind_i+N_sym)
    window = np.zeros(N_samples)
    window[ind_i:ind_f] = np.ones(ind_f-ind_i)

    f_min, f_max, N_f = -500e6,500e6,101
    f_offset_array = np.linspace(f_min,f_max,N_f)
    P_array_x = np.linspace(f_min,f_max,N_f)
    P_array_y = np.linspace(f_min,f_max,N_f)
    for counter, offset in enumerate(f_offset_array):
        s_shift_x = np.exp(1j*2*np.pi*offset*t)*s_x
        S_shift_x = np.abs(np.fft.fftshift(np.fft.fft(s_shift_x)))
        S_f_x = S_shift_x*window
        P_array_x[counter] = sum(np.abs(S_f_x)**2)
        s_shift_y = np.exp(1j*2*np.pi*offset*t)*s_y
        S_shift_y = np.abs(np.fft.fftshift(np.fft.fft(s_shift_y)))
        S_f_y = S_shift_y*window
        P_array_y[counter] = sum(np.abs(S_f_y)**2)

    max_offset_opt = max(P_array)
    ind_offset_opt = np.where(P_array==max_offset_opt)
    f_offset_opt = f_offset_array[ind_offset_opt[0][0]]

    # Refining
    p = np.polyfit(f_offset_array,P_array,4)
    N_f = 2001
    f_offset_array_ext = np.linspace(f_min,f_max,N_f)
    P_array_ext = np.polyval(p,f_offset_array_ext)
    if plot_flag:
        plt.figure()
        plt.plot(f_offset_array/1e6,P_array,'o')
        plt.plot(f_offset_array_ext/1e6,P_array_ext)
        plt.ylabel('Power [a.u.]')
        plt.xlabel('Frequency offset [MHz]')

    max_offset_opt = max(P_array_ext)
    ind_offset_opt = np.where(P_array_ext==max_offset_opt)
    f_offset_opt = f_offset_array_ext[ind_offset_opt[0][0]]

    #f_offset_opt = 0
    s = np.exp(1j*2*np.pi*f_offset_opt*t)*s

    #s = s_in

    # Filter the signal using a Nyquist filter
    N_samples = len(s)
    N_sym = int(N_samples/SpS)
    S_nyq = np.zeros(N_samples,dtype=complex)
    ind_i = int(N_samples/2-N_sym-N_sym/2)
    ind_f = ind_i+N_sym

    ind = np.arange(N_samples)
    N_aux = int(RollOff*N_sym)
    ind_aux = np.arange(int(N_aux))
    s_aux_1 = 1*np.ones(N_aux)   #0.5*(1-np.cos(np.pi*ind_aux/N_aux))
    s_aux_2 = 1*np.ones(N_aux)   #0.5*(1+np.cos(np.pi*ind_aux/N_aux))
    window = np.zeros(N_samples)
    ind_i_1 = int(N_samples/2-N_sym/2-N_aux/2)
    ind_f_1 = ind_i_1+int(N_aux)
    window[ind_i_1:ind_f_1] = s_aux_1
    ind_i_2 = int(N_samples/2+N_sym/2-N_aux/2)
    ind_f_2 = ind_i_2+int(N_aux)
    window[ind_i_2:ind_f_2] = s_aux_2
    window[ind_f_1:ind_i_2] = np.ones(ind_i_2-ind_f_1)
    S = np.fft.fftshift(np.fft.fft(s))
    S_f = S*window
    s_f = SpS*np.fft.ifft(np.fft.ifftshift(S_f))
    s = s_f
    #s = s_in

    if plot_flag:
        plt.figure()
        plt.plot(f/1e9,20*np.log10(np.abs(S)/max(np.abs(S))),label='signal')
        plt.plot(f/1e9,20*np.log10(window/max(np.abs(window))),label='filter')
        plt.ylabel('Normalized power / Filter resp. [dB]')
        plt.xlabel('Frequency [GHz]')

    # Generation of the sync sequence
    # Initial zeros
    s_zeros_init = np.zeros(10,dtype=complex)
    # Sync sequence
    np.random.seed(sync_seed)
    s_sync_i = np.random.randint(0,2,N_sync,dtype=int)*2-1
    # Final zeros
    s_zeros_final = np.zeros(10,dtype=complex)
    s_b_i = np.concatenate([s_zeros_init,s_sync_i,s_zeros_final])
    # Digital-to-analogue conversion of the synchronization sequence
    s_sync_i = DAC_Nyquist(s=s_b_i,SpS=SpS,RollOff=RollOff)

    # Correlation between signal and synchronization
    s_xx_i = np.correlate(s,s_sync_i)
    if plot_flag:
        plt.figure()
        plt.plot(abs(s_xx_i))
        plt.ylabel('Cross-correlation')
        plt.xlabel('Sample index')
        plt.xlim([0,len(s_xx_i)])

    # Generating the index of the maximum correlation
    max_i = np.max(np.abs(s_xx_i))
    ind_i = np.where(max_i==np.abs(s_xx_i))
    # Finding the inidices of the sync and information
    ind_sync = (np.arange(N_sync)+10)*SpS+ind_i[0][0]
    ind_inf = (np.arange(N_inf)+10+N_sync)*SpS+ind_i[0][0]
    # Sampling the signal
    s_sync = s[ind_sync]
    s_inf = s[ind_inf]

    if plot_flag:
        # In-phase component time domain
        plt.figure()
        plt.plot(t*1e9,np.real(s))
        plt.plot(ind_sync*ts*1e9,np.real(s_sync),'.')
        plt.plot(ind_inf*ts*1e9,np.real(s_inf),'.')
        plt.xlabel('Time [ns]')
        plt.ylabel('In-phase component [a.u.]')
        plt.title('Raw data')
        plt.xlim([0,np.max(t)*1e9])

        # Contellation
        plt.figure()
        plt.plot(np.real(s_inf),np.imag(s_inf),'.')
        plt.plot(np.real(s_sync),np.imag(s_sync),'.')
        plt.axis('square')
        plt.xlabel('In-phase [a.u.]')
        plt.ylabel('Quadrature [a.u.]')
        plt.title('Raw data')

    # Finding the rotation angle
    theta_hat = np.angle(s_xx_i[ind_i])
    s = s*np.exp(-1j*theta_hat)
    s_sync = s_sync*np.exp(-1j*theta_hat)
    s_inf = s_inf*np.exp(-1j*theta_hat)

    if plot_flag:
        # In-phase component time domain
        plt.figure()
        plt.plot(t*1e9,np.real(s))
        plt.plot(ind_sync*ts*1e9,np.real(s_sync),'.')
        plt.plot(ind_inf*ts*1e9,np.real(s_inf),'.')
        plt.xlabel('Time [ns]')
        plt.ylabel('In-phase component [a.u.]')
        plt.title('After phase rotation')
        plt.xlim([0,np.max(t)*1e9])

        # Contellation
        plt.figure()
        plt.plot(np.real(s_inf),np.imag(s_inf),'.')
        plt.plot(np.real(s_sync),np.imag(s_sync),'.')
        plt.axis('square')
        plt.xlabel('In-phase [a.u.]')
        plt.ylabel('Quadrature [a.u.]')
        plt.title('After phase rotation')

    # Finding the scaling factor
    K = max_i/1940
    s = s/K
    s_sync = s_sync/K
    s_inf = s_inf/K
    if plot_flag:
        # In-phase component time domain
        plt.figure()
        plt.plot(t*1e9,np.real(s))
        plt.plot(ind_sync*ts*1e9,np.real(s_sync),'.')
        plt.plot(ind_inf*ts*1e9,np.real(s_inf),'.')
        plt.xlabel('Time [ns]')
        plt.ylabel('In-phase component [a.u.]')
        plt.title('After scaling correction')
        plt.xlim([0,np.max(t)*1e9])

        # Contellation
        plt.figure()
        plt.plot(np.real(s_inf),np.imag(s_inf),'.')
        plt.plot(np.real(s_sync),np.imag(s_sync),'.')
        plt.axis('square')
        plt.xlabel('In-phase [a.u.]')
        plt.ylabel('Quadrature [a.u.]')
        plt.title('After scaling correction')

    # Desnormalized the amplitude of the modulated signal
    if M == 16:
        s_inf_dn = 3*s_inf
    if M == 32:
        s_inf_dn = 5*s_inf

    # Blind phase noise and residual frequency offset compensation
    N_block = 16
    N_overlap = 8

    ind_1 = 0
    ind_2 = ind_1+N_block
    phi = 0
    min_dphi = -np.pi/4
    max_dphi = np.pi/4
    N_dphi = 21
    dphi_array = np.linspace(min_dphi,max_dphi,N_dphi)

    phi_array = np.array([0])
    ind_array = np.array([0])
    counter1 = 0
    while ind_2<=len(s_inf_dn):
        s_block = s_inf_dn[ind_1:ind_2]
        d_array_block = np.zeros(N_dphi)
        for counter, dphi in enumerate(dphi_array):
            s_block_rot = s_block*np.exp(1j*(dphi+phi))
            s_hat, dist = QAM_dem(s_block_rot,M)
            d_array_block[counter] = np.var(dist)

        #plt.figure()
        #plt.plot(d_array_block)

        d_min = min(d_array_block)
        ind_min = np.where(d_array_block==d_min)
        dphi_opt = dphi_array[ind_min[0][0]]
        phi = phi+dphi_opt
        counter1 += 1
        phi_array = np.append(phi_array, phi)
        ind_array = np.append(ind_array, int((ind_2+ind_1)/2))
        ind_1 = ind_1+N_block-N_overlap
        ind_2 = ind_1+N_block

    ind_array = np.concatenate(([0],ind_array,[len(s_inf_dn)]))
    phi_array = np.concatenate(([0],phi_array,[phi_array[-1]]))
    phi_interp = np.interp(np.arange(len(s_inf_dn)),ind_array,phi_array)

    if plot_flag:
        plt.figure()
        plt.plot(phi_interp)
        #print(len(phi_interp))
    s_inf_pc = s_inf_dn*np.exp(1j*phi_interp)

    if plot_flag:
        # Contellation
        plt.figure()
        plt.plot(np.real(s_inf_pc),np.imag(s_inf_pc),'.')
        plt.axis('square')
        plt.xlabel('In-phase [a.u.]')
        plt.ylabel('Quadrature [a.u.]')
        plt.title('After scaling correction')

    #f plot_flag:
    #   constellation_analysis(s_inf_pc)
    #constellation_analysis(s_inf_pc)

    # Demapping
    s_hat, dist = QAM_dem(s_inf_pc,M)

    if plot_flag:
        plt.figure()
        plt.stem(s_hat!=s_b)

    BER = np.mean(s_hat!=s_b)

    return [s_inf, s_sync, s_inf_dn, BER]

"""### 6.1.3 Optical and electro-optical modules"""

def single_frequency_laser(t = None, P = 0.01, Delta_nu = 1e6, Freq_offset = 0, X_fraction = 1, phi_pol = 0):
    # Calculate the amplitude
    A = np.sqrt(P)
    # Calculate the phase noise
    ts = t[1]-t[0]
    freq_noise = np.sqrt(2*np.pi*Delta_nu*ts)*np.random.randn(len(t))
    phase_noise = np.cumsum(freq_noise)
    # Frequency offset
    phase = 2*np.pi*(Freq_offset)*t+phase_noise
    # Generation of the signal
    s = A*np.exp(1j*phase)
    Ax = np.sqrt(X_fraction)*np.exp(1j*phi_pol/2)*s
    Ay = np.sqrt(1-X_fraction)*np.exp(-1j*phi_pol/2)*s
    A = np.zeros((2,len(t)),dtype=complex)
    #print(np.shape(A))
    A[0,:] = Ax
    A[1,:] = Ay
    return(A)

def MZM(A,Vrf_upper,Vrf_lower,Splitter_IL=1.0,Upper_IL=2.0,Lower_IL=3.0,Combiner_IL=1.1,Vpi = 5,Vbias=2.5):
    Aupper_1 = A/2*10**(-Splitter_IL/20)
    Alower_1 = A/2*10**(-Splitter_IL/20)
    Aupper_2 = Aupper_1*np.exp(1j*(-Vrf_upper+Vbias/2)/Vpi*np.pi)
    Alower_2 = Alower_1*np.exp(1j*(-Vrf_lower-Vbias/2)/Vpi*np.pi)
    Aupper_3 = Aupper_2*10**(-Upper_IL/20)
    Alower_3 = Alower_2*10**(-Lower_IL/20)
    Aupper_4 = Aupper_3*10**(-Combiner_IL/20)
    Alower_4 = Alower_3*10**(-Combiner_IL/20)
    Aout = Aupper_4+Alower_4
    return Aout

def HybridNetwork(A_sig,A_LO):
    A_1 = 1/2*(A_sig+A_LO)
    A_2 = 1/2*(A_sig-A_LO)
    A_3 = 1/2*(A_sig+1j*A_LO)
    A_4 = 1/2*(A_sig-1j*A_LO)
    return [A_1,A_2,A_3,A_4]

def photodiode(s=None,t=None,R=0.9,BW=10e9,shot_noise=True,thermal_noise=True):
    ts = t[2]-t[1]
    fs = 1/ts
    BW_sim = 1/ts
    # Extract each polarization
    N = len(t)
    Ax = s[:]

    #print('The length of Ax is',np.shape(Ax))
    #print('The length of t is',np.shape(t))

    # Photodetection
    #I_opt = (np.abs(Ax))**2
    I_opt = np.multiply(abs(Ax),abs(Ax))
    i_pd = R*I_opt

    # Noise addition
    kB = 1.38e-23       # Boltzmann's constant in J/K
    Temp = 300          # Temperature in K
    Rl = 50             # Load resistance in Ohm
    q = 1.6e-19         # Electron charge in C
    if thermal_noise:
        # Thermal noise
        PSD_n_thermal = 4*kB*Temp/Rl
        P_n_thermal = PSD_n_thermal*BW_sim
        n_thermal = np.sqrt(P_n_thermal)*np.random.randn(1,N)
    else:
        n_thermal = 0

    if shot_noise:
        # Shot noise
        PSD_n_shot = 2*q*np.mean(np.abs(i_pd))
        P_n_shot = PSD_n_shot*BW_sim
        n_shot = np.sqrt(P_n_shot)*np.random.randn(1,N)
    else:
        n_shot = 0
    i_pd = i_pd + n_thermal+n_shot

    # Filtering
    wp = BW
    ws = 1.5*wp      # Begin of the stop band
    gpass = 3        # Maximum loss in the pass band in dB
    gstop = 20       # Minimum loss in the stop band in dB
    analog = False   #

    # Finding the order
    No, Wn = signal.ellipord(wp, ws, gpass, gstop, analog, fs)

    # Create the filter
    b, a = signal.ellip(No, gpass, gstop, Wn, btype='low', analog=False, fs=fs)

    i_pd = signal.lfilter(b,a,i_pd)

    return i_pd


# Function that simulates the fiber using the SSFM
def fiber(A=0,t=0,L=100e3,DeltaL=1e3,D=16e-6,lambda0=1550e-9,alpha_dB=0.2e-3,n2=2.6e-20,Aeff=80e-12,SoP_rotation=None):
    # E: input electrical double-polarization field in V/m
    # t: time vector in [s]
    # L: fiberl length in [m]
    # DeltaL: the longitudinal step value in [m]
    # D: dispersion parameter in [s/m^2]
    # lambda0: operation wavelength
    # alpha_dB: attenuation coefficient in dB/m
    # n2: nonlinear refractive index in [W-1]
    # Aeff: effective modal area in [mˆ2]

    # Constants
    c = 3e8             # Speed of light in the vacuum in m/s
    pi = np.pi          # Pi number

    # Preliminary calculations
    Nt = len(t)                    # Number of time samples
    Deltat = t[1]-t[0]             # Time step in s
    fs = 1/Deltat                  # Sampling frequency in Hz
    f = np.arange(Nt)/(Nt/fs)-fs/2 # Frequency vector in Hz
    Nz = int(L/DeltaL)             # Number of segments
    z = np.linspace(0,L-DeltaL,Nz) # Propagation distance vector in m
    alpha_Np = alpha_dB/4.343      # Attenuation of in Np/m
    k = 2*pi/lambda0               # Wave number in m-1
    gamma = n2*k/Aeff              # Nonlinear coefficient in W-1m-1

    # Extraction of the polarizations
    Ax = A[0,:]                    # We extract the x polarization
    Ay = A[1,:]                    # We extract the y polarization

    # Propagate through the fiber
    for auxz in range(len(z)):

        # Scalar linear effects are simulated in the frequency domain

        # Conversion to frequency domain
        Ax_f = np.fft.fftshift(np.fft.fft(Ax))
        Ay_f = np.fft.fftshift(np.fft.fft(Ay))

        # Attenuation
        Ax_f = Ax_f*np.exp(-alpha_Np/2*DeltaL)
        Ay_f = Ay_f*np.exp(-alpha_Np/2*DeltaL)

        # Dispersion
        Ax_f *= np.exp(-1j*(D*lambda0**2/(4*np.pi*c)*DeltaL*((2*np.pi)*f)**2))
        Ay_f *= np.exp(-1j*(D*lambda0**2/(4*np.pi*c)*DeltaL*((2*np.pi)*f)**2))

        # Conversion to time domain
        Ax = np.fft.ifft(np.fft.ifftshift(Ax_f))
        Ay = np.fft.ifft(np.fft.ifftshift(Ay_f))

        # Nonlinear effects are simulated in the time domain
        Ixy = (abs(Ax))**2+(abs(Ay))**2
        Ax *= np.exp(1j*gamma*Ixy*DeltaL);
        Ay *= np.exp(1j*gamma*Ixy*DeltaL);

        # Polarization rotation can be performed either in time or frequency domain
        if SoP_rotation:
            theta_rand = np.random.rand(1)*np.pi
            phi_rand = np.random.rand(1)*2*np.pi
            Ax_aux = Ax * np.exp(1j*phi_rand/2)
            Ay_aux = Ay * np.exp(-1j*phi_rand/2)
            Ax = np.cos(theta_rand)*Ax_aux+np.sin(theta_rand)*Ay_aux
            Ay = -np.sin(theta_rand)*Ax_aux+np.cos(theta_rand)*Ay_aux

    # Create the output field from the two polarizations
    A = np.zeros((2,len(t)),dtype = np.complex_)
    A[0,:] = Ax
    A[1,:] = Ay
    return A

# Function that simulates the fiber using the SSFM
def fiber(A=0,t=0,L=100e3,DeltaL=1e3,D=16e-6,lambda0=1550e-9,alpha_dB=0.2e-3,n2=2.6e-20,Aeff=80e-12,SoP_rotation=None):
    # E: input electrical double-polarization field in V/m
    # t: time vector in [s]
    # L: fiberl length in [m]
    # DeltaL: the longitudinal step value in [m]
    # D: dispersion parameter in [s/m^2]
    # lambda0: operation wavelength
    # alpha_dB: attenuation coefficient in dB/m
    # n2: nonlinear refractive index in [W-1]
    # Aeff: effective modal area in [mˆ2]

    # Constants
    c = 3e8             # Speed of light in the vacuum in m/s
    pi = np.pi          # Pi number

    # Preliminary calculations
    Nt = len(t)                    # Number of time samples
    Deltat = t[1]-t[0]             # Time step in s
    fs = 1/Deltat                  # Sampling frequency in Hz
    f = np.arange(Nt)/(Nt/fs)-fs/2 # Frequency vector in Hz
    Nz = int(L/DeltaL)             # Number of segments
    z = np.linspace(0,L-DeltaL,Nz) # Propagation distance vector in m
    alpha_Np = alpha_dB/4.343      # Attenuation of in Np/m
    k = 2*pi/lambda0               # Wave number in m-1
    gamma = n2*k/Aeff              # Nonlinear coefficient in W-1m-1

    # Extraction of the polarizations
    Ax = A[0,:]                    # We extract the x polarization
    Ay = A[1,:]                    # We extract the y polarization

    # Propagate through the fiber
    for auxz in range(len(z)):

        # Scalar linear effects are simulated in the frequency domain

        # Conversion to frequency domain
        Ax_f = np.fft.fftshift(np.fft.fft(Ax))
        Ay_f = np.fft.fftshift(np.fft.fft(Ay))

        # Attenuation
        Ax_f = Ax_f*np.exp(-alpha_Np/2*DeltaL)
        Ay_f = Ay_f*np.exp(-alpha_Np/2*DeltaL)

        # Dispersion
        Ax_f *= np.exp(-1j*(D*lambda0**2/(4*np.pi*c)*DeltaL*((2*np.pi)*f)**2))
        Ay_f *= np.exp(-1j*(D*lambda0**2/(4*np.pi*c)*DeltaL*((2*np.pi)*f)**2))

        # Conversion to time domain
        Ax = np.fft.ifft(np.fft.ifftshift(Ax_f))
        Ay = np.fft.ifft(np.fft.ifftshift(Ay_f))

        # Nonlinear effects are simulated in the time domain
        Ixy = (abs(Ax))**2+(abs(Ay))**2
        Ax *= np.exp(1j*gamma*Ixy*DeltaL);
        Ay *= np.exp(1j*gamma*Ixy*DeltaL);

        # Polarization rotation can be performed either in time or frequency domain
        if SoP_rotation:
            theta_rand = np.random.rand(1)*np.pi
            phi_rand = np.random.rand(1)*2*np.pi
            Ax_aux = Ax * np.exp(1j*phi_rand/2)
            Ay_aux = Ay * np.exp(-1j*phi_rand/2)
            Ax = np.cos(theta_rand)*Ax_aux+np.sin(theta_rand)*Ay_aux
            Ay = -np.sin(theta_rand)*Ax_aux+np.cos(theta_rand)*Ay_aux

    # Create the output field from the two polarizations
    A = np.zeros((2,len(t)),dtype = np.complex_)
    A[0,:] = Ax
    A[1,:] = Ay
    return A

def EDFA(s_in,t,G_edfa_dB,NF_dB,lambda0=1550e-9):
    h = 6.626e-34     # Planck's constant in J/Hz
    c = 3e8           # Speed of light in the vacuum in m/s
    f0 = c/lambda0    # Operation frequency in Hz
    ts = t[1]-t[0]    # Sampling time in s
    fs = 1/ts         # Sampling frequency in Hz
    BW_sim = fs       # Simulation bandwidth in Hz

    # Gain
    G_edfa = 10**(G_edfa_dB/10)
    sx = s_in[0]
    sy = s_in[1]
    N = len(sx)

    sx = np.sqrt(G_edfa)*sx
    sy = np.sqrt(G_edfa)*sy

    # Noise
    F_n = 10**(NF_dB/10)
    n_sp = F_n/2
    S_ASE = n_sp*h*f0*(G_edfa-1)
    P_ASE = S_ASE*BW_sim

    s_ASEx = np.sqrt(P_ASE)/2*np.random.rand(N)+1j*np.sqrt(P_ASE)/2*np.random.rand(N)
    s_ASEy = np.sqrt(P_ASE)/2*np.random.rand(N)+1j*np.sqrt(P_ASE)/2*np.random.rand(N)
    s_outx = sx + s_ASEx
    s_outy = sy + s_ASEy

    s = np.zeros((2,len(t)),dtype = np.complex_)
    s[0,:] = s_outx
    s[1,:] = s_outy
    return s

"""### 6.1.2 Visualization functions"""

def constellation_analysis(s):
    plt.figure()
    plt.plot(np.real(s),np.imag(s),'.')

    H, xedges, yedges = np.histogram2d(np.real(s),np.imag(s),100)
    #plt.figure()
    #plt.contourf(counts)

    fig = plt.figure()
    #ax = fig.add_subplot(131, title='imshow: square bins')
    plt.imshow(np.log10(H), interpolation='nearest', origin='lower', extent=[xedges[0], xedges[-1], yedges[0], yedges[-1]],cmap="hot")

    fig = plt.figure()
    #ax = fig.add_subplot(131, title='imshow: square bins')
    plt.imshow(H,cmap="hot")

    fig = plt.figure()
    #ax = fig.add_subplot(131, title='imshow: square bins')
    plt.imshow(np.log10(H), interpolation='nearest', origin='lower', extent=[xedges[0], xedges[-1], yedges[0], yedges[-1]],cmap="Blues")

    fig = plt.figure()
    #ax = fig.add_subplot(131, title='imshow: square bins')
    plt.imshow(H,cmap="Blues")

def spectrum_analysis(s,t):
    ts = t[1]-t[0]                       # Sampling period in s
    fs = 1/ts                            # Sampling frequancy in Hz
    Deltaf = 1/(ts*len(t))               # Frequency resolution in Hz
    f = np.arange(len(t))*Deltaf-fs/2    # Frequency vector in Hz

    plt.figure()
    plt.plot(f/1e9,30+10*np.log10(np.fft.fftshift(np.abs(np.fft.fft(s)))))
    plt.xlabel('Frequency [GHz]')
    plt.ylabel('Power [dBm]')

"""### 6.1.4 Optical transmitter and receiver"""

# DP-QAM transmitter
def DPQAM_transmitter(M = 16, SpS = 16, RollOff = 0.2, ts = 1e-9, sync_seed_X=0,sync_seed_Y=123,\
                           N_MIMO = 128,N_sync = 128,N_inf = 4096,N_zeros_init=10,N_zeros_final=10,Delta_nu=0,Freq_offset=0,\
                           ind_mod = 0.1, Splitter_IL=1.0,Upper_IL=2.0,Lower_IL=2.0,Combiner_IL=1.1,\
                           Vpi = 2.5, Vbias=2.5, plot_flag = False):

    #------------------------------------- Electrical signal --------------------------------------------%
    # Complex signal for X polarization
    s_tx_X, t, s_b_X = QAM_transmitter(M = M, SpS = SpS, RollOff = RollOff,ts = ts,sync_seed=sync_seed_X,\
                           N_sync = N_sync,N_MIMO=N_MIMO,MIMO_i=0,N_inf = N_inf,N_zeros_init=N_zeros_init,N_zeros_final=N_zeros_final,\
                           plot_flag = False)

    # Complex signal for Y polarization
    s_tx_Y, t, s_b_Y = QAM_transmitter(M = M, SpS = SpS, RollOff = RollOff,ts = ts,sync_seed=sync_seed_Y,\
                           N_sync = N_sync,N_MIMO=N_MIMO,MIMO_i=1,N_inf = N_inf,N_zeros_init=N_zeros_init,N_zeros_final=N_zeros_final,\
                           plot_flag = False)

    # Combination of the signals for both polarizations
    # Binary sequences
    s_b = np.zeros((2,len(s_b_X)),dtype=int)
    s_b[0,:] = s_b_X
    s_b[1,:] = s_b_Y
    # Electrical signals
    s_tx = np.zeros((2,len(t)),dtype=complex)
    s_tx[0,:] = s_tx_X
    s_tx[1,:] = s_tx_Y

    #--------------------------------------- Optical signal ---------------------------------------------%
    E_carrier = single_frequency_laser(t = t, P = P_laser_TX, Delta_nu = Delta_nu,\
                                       Freq_offset = Freq_offset,X_fraction = 0.5, phi_pol = 0)

    # Polarization splitting
    E_carrier_X = E_carrier[0,:]
    E_carrier_Y = E_carrier[1,:]

    #------------------------------------- Optical modulation --------------------------------------------%
    # Modulation depth
    Kmod = ind_mod

    # Modulation of the X component
    # Modulation of the in-phase component of the X polarization
    E_carrier_X_I = E_carrier_X/np.sqrt(2)
    s_tx_X_I = np.real(s_tx_X)
    Vrf_upper = Kmod*s_tx_X_I
    Vrf_lower = -Kmod*s_tx_X_I
    E_mod_X_I = MZM(E_carrier_X_I,Vrf_upper,Vrf_lower,Splitter_IL=Splitter_IL,Upper_IL=Upper_IL,\
                    Lower_IL=Lower_IL,Combiner_IL=Combiner_IL,Vpi = Vpi,Vbias=Vbias)
    # Modulation of the in-phase component of the X polarization
    E_carrier_X_Q = E_carrier_X/np.sqrt(2)*np.exp(1j*np.pi/2)
    s_tx_X_Q = np.imag(s_tx_X)
    Vrf_upper = Kmod*s_tx_X_Q
    Vrf_lower = -Kmod*s_tx_X_Q
    E_mod_X_Q = MZM(E_carrier_X_Q,Vrf_upper,Vrf_lower,Splitter_IL=Splitter_IL,Upper_IL=Upper_IL,\
                    Lower_IL=Lower_IL,Combiner_IL=Combiner_IL,Vpi = Vpi,Vbias=Vbias)
    # Combine the components
    E_mod_X = 1/np.sqrt(2)*E_mod_X_I+1/np.sqrt(2)*E_mod_X_Q

    # Modulation of the Y component
    # Modulation of the in-phase component of the Y polarization
    E_carrier_Y_I = E_carrier_Y/np.sqrt(2)
    s_tx_Y_I = np.real(s_tx_Y)
    Vrf_upper = Kmod*s_tx_Y_I
    Vrf_lower = -Kmod*s_tx_Y_I
    E_mod_Y_I = MZM(E_carrier_Y_I,Vrf_upper,Vrf_lower,Splitter_IL=Splitter_IL,Upper_IL=Upper_IL,\
                    Lower_IL=Lower_IL,Combiner_IL=Combiner_IL,Vpi = Vpi,Vbias=Vbias)
    # Modulation of the in-phase component of the X polarization
    E_carrier_Y_Q = E_carrier_Y/np.sqrt(2)*np.exp(1j*np.pi/2)
    s_tx_Y_Q = np.imag(s_tx_Y)
    Vrf_upper = Kmod*s_tx_Y_Q
    Vrf_lower = -Kmod*s_tx_Y_Q
    E_mod_Y_Q = MZM(E_carrier_Y_Q,Vrf_upper,Vrf_lower,Splitter_IL=Splitter_IL,Upper_IL=Upper_IL,\
                    Lower_IL=Lower_IL,Combiner_IL=Combiner_IL,Vpi = Vpi,Vbias=Vbias)
    # Combine the components
    E_mod_Y = 1/np.sqrt(2)*E_mod_Y_I+1/np.sqrt(2)*E_mod_Y_Q

    if plot_flag:
        plt.figure()
        plt.subplot(2,1,1)
        plt.plot(np.real(E_mod_X))
        plt.plot(np.imag(E_mod_X))
        plt.subplot(2,1,2)
        plt.plot(np.real(E_mod_Y))
        plt.plot(np.imag(E_mod_Y))

    # Combine polarizations
    E_opt = np.zeros((2,len(t)),dtype=complex)
    #print(np.shape(A))
    E_opt[0,:] = E_mod_X
    E_opt[1,:] = E_mod_Y

    return [t, E_opt, E_carrier, s_tx, s_b]

# Dual polarization receiver
def QAM_receiver_DP(s,t,s_b,M,N_sync=128,N_MIMO=32,N_inf=4096,SpS=16,RollOff=0.2,sync_seed_X=0,sync_seed_Y=123,ts=1e-12,plot_flag=False,L=10e3,D=16e-6):
    #print('The length is',L)
    #print('The sipersion parameters is',D)
    s_in = s
    s_x = s[0,:]
    s_y = s[1,:]

    # Generation of time vector
    N_samples = len(s_x)
    t = ts*(np.arange(N_samples))
    fs = 1/ts
    f = (np.arange(N_samples)/N_samples)*fs-fs/2

    # Coarse frequency offset compensation
    N_samples = len(s_x)
    N_sym = int(N_samples/SpS)
    S_nyq = np.zeros(N_samples,dtype=complex)
    ind_i = int(N_samples/2-N_sym/2)
    ind_f = int(ind_i+N_sym)
    window = np.zeros(N_samples)
    window[ind_i:ind_f] = np.ones(ind_f-ind_i)

    f_min, f_max, N_f = -500e6,500e6,101
    f_offset_array = np.linspace(f_min,f_max,N_f)
    P_array_x = np.linspace(f_min,f_max,N_f)
    P_array_y = np.linspace(f_min,f_max,N_f)
    for counter, offset in enumerate(f_offset_array):
        s_shift_x = np.exp(1j*2*np.pi*offset*t)*s_x
        S_shift_x = np.abs(np.fft.fftshift(np.fft.fft(s_shift_x)))
        S_f_x = S_shift_x*window
        P_array_x[counter] = sum(np.abs(S_f_x)**2)

        s_shift_y = np.exp(1j*2*np.pi*offset*t)*s_y
        S_shift_y = np.abs(np.fft.fftshift(np.fft.fft(s_shift_y)))
        S_f_y = S_shift_y*window
        P_array_y[counter] = sum(np.abs(S_f_y)**2)
    P_array = (P_array_x+P_array_y)/2

    Npolord = 10
    max_offset_opt_x = max(P_array_x)
    ind_offset_opt_x = np.where(P_array_x==max_offset_opt_x)
    f_offset_opt_x = f_offset_array[ind_offset_opt_x[0][0]]
    p_x = np.polyfit(f_offset_array,P_array_x,Npolord)
    max_offset_opt_y = max(P_array_y)
    ind_offset_opt_y = np.where(P_array_y==max_offset_opt_y)
    f_offset_opt_y = f_offset_array[ind_offset_opt_y[0][0]]
    p_y = np.polyfit(f_offset_array,P_array_y,Npolord)
    max_offset_opt = max(P_array)
    ind_offset_opt = np.where(P_array==max_offset_opt)
    f_offset_opt = f_offset_array[ind_offset_opt[0][0]]
    p = np.polyfit(f_offset_array,P_array,Npolord)

    N_f = 2001
    f_offset_array_ext = np.linspace(f_min,f_max,N_f)
    P_array_ext_x = np.polyval(p_x,f_offset_array_ext)
    P_array_ext_y = np.polyval(p_y,f_offset_array_ext)
    P_array_ext = np.polyval(p,f_offset_array_ext)

    max_offset_opt_x = max(P_array_ext_x)
    ind_offset_opt_x = np.where(P_array_ext_x==max_offset_opt_x)
    f_offset_opt_x = f_offset_array_ext[ind_offset_opt_x[0][0]]

    max_offset_opt_y = max(P_array_ext_y)
    ind_offset_opt_y = np.where(P_array_ext_y==max_offset_opt_y)
    f_offset_opt_y = f_offset_array_ext[ind_offset_opt_y[0][0]]

    max_offset_opt = max(P_array_ext)
    ind_offset_opt = np.where(P_array_ext==max_offset_opt)
    f_offset_opt = f_offset_array_ext[ind_offset_opt[0][0]]

    if plot_flag:
        plt.figure()
        plt.plot(f_offset_array/1e6,P_array_x,'o')
        plt.plot(f_offset_array/1e6,P_array_y,'o')
        plt.plot(f_offset_array/1e6,P_array,'o')
        plt.plot(f_offset_array_ext/1e6,P_array_ext_x)
        plt.plot(f_offset_array_ext/1e6,P_array_ext_y)
        plt.plot(f_offset_array_ext/1e6,P_array_ext)
        plt.plot(f_offset_array_ext[ind_offset_opt_x[0][0]]/1e6,max_offset_opt_x,'^r')
        plt.plot(f_offset_array_ext[ind_offset_opt_y[0][0]]/1e6,max_offset_opt_y,'^r')
        plt.plot(f_offset_array_ext[ind_offset_opt[0][0]]/1e6,max_offset_opt,'^r')
        plt.ylabel('Power [a.u.]')
        plt.xlabel('Frequency offset [MHz]')

    #print('The frequency offset for x is:',f_offset_opt_x/1e6)
    #print('The frequency offset for y is:',f_offset_opt_y/1e6)
    #print('The frequency offset for x-y is:',f_offset_opt/1e6)
    s = np.exp(1j*2*np.pi*f_offset_opt*t)*s
    #s = s_in

    # Filter the signal using a square filter
    N_samples = len(s[0,:])
    N_sym = int(N_samples/SpS)
    S_nyq = np.zeros(N_samples,dtype=complex)
    ind_i = int(N_samples/2-N_sym-N_sym/2)
    ind_f = ind_i+N_sym

    ind = np.arange(N_samples)
    N_aux = int(RollOff*N_sym)
    ind_aux = np.arange(int(N_aux))
    s_aux_1 = 1*np.ones(N_aux)   #0.5*(1-np.cos(np.pi*ind_aux/N_aux))
    s_aux_2 = 1*np.ones(N_aux)   #0.5*(1+np.cos(np.pi*ind_aux/N_aux))
    window = np.zeros(N_samples)
    ind_i_1 = int(N_samples/2-N_sym/2-N_aux/2)
    ind_f_1 = ind_i_1+int(N_aux)
    window[ind_i_1:ind_f_1] = s_aux_1
    ind_i_2 = int(N_samples/2+N_sym/2-N_aux/2)
    ind_f_2 = ind_i_2+int(N_aux)
    window[ind_i_2:ind_f_2] = s_aux_2
    window[ind_f_1:ind_i_2] = np.ones(ind_i_2-ind_f_1)

    sx = s[0,:]
    Sx = np.fft.fftshift(np.fft.fft(sx))
    S_f_x = Sx*window
    s_f_x = SpS*np.fft.ifft(np.fft.ifftshift(S_f_x))
    sy = s[1,:]
    Sy = np.fft.fftshift(np.fft.fft(sy))
    S_f_y = Sy*window
    s_f_y = SpS*np.fft.ifft(np.fft.ifftshift(S_f_y))

    s[0,:] = s_f_x
    s[1,:] = s_f_y
    #s = s_in

    #s = s_in

    if plot_flag:
        epsilon = 1e-12
        plt.figure()
        plt.plot(f/1e9,20*np.log10(np.abs(Sx)/max(np.abs(Sx))+epsilon),label='signal')
        plt.plot(f/1e9,20*np.log10(np.abs(Sy)/max(np.abs(Sy))+epsilon),label='signal')
        plt.plot(f/1e9,20*np.log10(np.abs(S_f_x)/max(np.abs(S_f_x))+epsilon),label='signal')
        plt.plot(f/1e9,20*np.log10(np.abs(S_f_y)/max(np.abs(S_f_y))+epsilon),label='signal')
        plt.plot(f/1e9,20*np.log10(window/max(np.abs(window))+epsilon),label='filter')
        plt.ylabel('Normalized power / Filter resp. [dB]')
        plt.xlabel('Frequency [GHz]')

    ####### Dispersion compensation #########

    # Conversion to frequency domain
    s_f_x_f = np.fft.fftshift(np.fft.fft(s_f_x))
    s_f_y_f = np.fft.fftshift(np.fft.fft(s_f_y))

    # Dispersion
    c = 3e8
    lambda0 = 1550e-9
    s_f_x_f *= np.exp(1j*(D*lambda0**2/(4*np.pi*c)*L*((2*np.pi)*f)**2))
    s_f_y_f *= np.exp(1j*(D*lambda0**2/(4*np.pi*c)*L*((2*np.pi)*f)**2))

    # Conversion to time domain
    s_f_x = np.fft.ifft(np.fft.ifftshift(s_f_x_f))
    s_f_y = np.fft.ifft(np.fft.ifftshift(s_f_y_f))
    s[0,:] = s_f_x
    s[1,:] = s_f_y

    # Generation of the sync sequence
    # Initial zeros
    s_zeros_init = np.zeros(10,dtype=complex)
    # Sync sequence
    np.random.seed(sync_seed_X)
    s_sync_i_x_d = np.random.randint(0,2,N_sync,dtype=int)*2-1
    np.random.seed(sync_seed_Y)
    s_sync_i_y_d = np.random.randint(0,2,N_sync,dtype=int)*2-1

    # Final zeros
    s_zeros_final = np.zeros(10,dtype=complex)
    s_b_i_x = np.concatenate([s_zeros_init,s_sync_i_x_d,s_zeros_final])
    s_b_i_y = np.concatenate([s_zeros_init,s_sync_i_y_d,s_zeros_final])

    # Digital-to-analogue conversion of the synchronization sequence
    s_sync_i_x = DAC_Nyquist(s=s_b_i_x,SpS=SpS,RollOff=RollOff)
    s_sync_i_y = DAC_Nyquist(s=s_b_i_y,SpS=SpS,RollOff=RollOff)

    # Correlation between signal and synchronization
    sx = s[0,:]
    sy = s[1,:]
    s_xx_i = np.correlate(sx,s_sync_i_x)
    s_xy_i = np.correlate(sx,s_sync_i_y)
    s_yy_i = np.correlate(sy,s_sync_i_y)
    s_yx_i = np.correlate(sy,s_sync_i_x)

    if plot_flag:
        plt.figure()
        plt.plot(abs(s_xx_i))
        plt.plot(abs(s_xy_i))
        plt.plot(abs(s_yy_i))
        plt.plot(abs(s_yx_i))
        plt.ylabel('Cross-correlation')
        plt.xlabel('Sample index')
        plt.xlim([0,len(s_xx_i)])
    s_corr_total = abs(s_xx_i)+abs(s_xy_i)+abs(s_yy_i)+abs(s_yx_i)

    #print(N_sync)
    #kaixo

    # Generating the index of the maximum correlation
    max_i = np.max(s_corr_total)
    ind_i = np.where(max_i==s_corr_total)
    # Finding the inidices of the sync and information
    ind_sync = (np.arange(N_sync)+10)*SpS+ind_i[0][0]
    ind_MIMO = (np.arange(N_MIMO)+10+N_sync)*SpS+ind_i[0][0]
    ind_inf = (np.arange(N_inf)+10+N_sync)*SpS+ind_i[0][0]
    #print(N_sync)

    #print(max(abs(s_xx_i[ind_i])))
    #print(max(abs(s_xy_i[ind_i])))
    #print(max(abs(s_yy_i[ind_i])))
    #print(max(abs(s_yx_i[ind_i])))
    #print(max(np.angle(s_xx_i[ind_i])))
    #print(max(np.angle(s_xy_i[ind_i])))
    #print(max(np.angle(s_yy_i[ind_i])))
    #print(max(np.angle(s_yx_i[ind_i])))

    H_hat = np.zeros((2,2),dtype=complex)
    H_hat[0][0] = s_xx_i[ind_i][0]
    H_hat[0][1] = s_xy_i[ind_i][0]
    H_hat[1][0] = s_yx_i[ind_i][0]
    H_hat[1][1] = s_yy_i[ind_i][0]
    H_inv = np.linalg.inv(H_hat)

    #H_hat = np.matrix([[s_xx_i[ind_i][0],s_xy_i[ind_i]][0],[s_yx_i[ind_i][0],s_yy_i[ind_i][0]]])
    #print(H_hat)
    #print(H_inv)

    s_sync = s[:,ind_sync]
    s_sync_x = sx[ind_sync]
    s_sync_y = sy[ind_sync]
    s_inf = s[:,ind_inf]
    s_inf_x = s_inf[0,:]
    s_inf_y = s_inf[1,:]

    s_sync_corr = np.matmul(H_inv,s_sync)
    s_sync_corr_x = s_sync_corr[0,:]
    s_sync_corr_y = s_sync_corr[1,:]

    s_inf_corr = np.matmul(H_inv,s_inf)
    s_inf_corr_x = s_inf_corr[0,:]
    s_inf_corr_y = s_inf_corr[1,:]

    plt.figure()
    plt.subplot(2,1,1)
    plt.plot(np.real(s_sync_corr_x),'.')
    plt.plot(np.imag(s_sync_corr_x),'.')
    plt.plot(np.real(s_inf_corr_x),'.')
    plt.plot(np.imag(s_inf_corr_x),'.')

    plt.subplot(2,1,2)
    plt.plot(np.real(s_sync_corr_y),'.')
    plt.plot(np.imag(s_sync_corr_y),'.')
    plt.plot(np.real(s_inf_corr_y),'.')
    plt.plot(np.imag(s_inf_corr_y),'.')

    if plot_flag:
        # In-phase component time domain
        plt.figure()
        plt.plot(t*1e9,np.real(sx))
        plt.plot(ind_sync*ts*1e9,np.real(s_sync_x),'.')
        plt.plot(ind_inf*ts*1e9,np.real(s_inf_x),'.')
        plt.xlabel('Time [ns]')
        plt.ylabel('In-phase component [a.u.]')
        plt.title('Raw data')
        plt.xlim([0,np.max(t)*1e9])

        # Contellation
        plt.figure()
        plt.plot(np.real(s_inf_corr_x),np.imag(s_inf_corr_x),'.')
        plt.plot(np.real(s_sync_corr_x),np.imag(s_sync_corr_x),'.')
        plt.axis('square')
        plt.xlabel('In-phase [a.u.]')
        plt.ylabel('Quadrature [a.u.]')
        plt.title('Raw data')


    K_amp = np.mean(np.abs(s_sync_corr_x))
    #print(K_amp)

    s_sync_corr_x = s_sync_corr_x/K_amp
    s_sync_corr_y = s_sync_corr_y/K_amp
    s_inf_corr_x = s_inf_corr_x/K_amp
    s_inf_corr_y = s_inf_corr_y/K_amp

    # Contellation
    plt.figure()
    plt.plot(np.real(s_inf_corr_x),np.imag(s_inf_corr_x),'.')
    plt.plot(np.real(s_sync_corr_x),np.imag(s_sync_corr_x),'.')
    plt.axis('square')
    plt.xlabel('In-phase [a.u.]')
    plt.ylabel('Quadrature [a.u.]')
    plt.title('Raw data')

    # Desnormalized the amplitude of the modulated signal
    if M == 16:
        sx_inf_dn = 3*s_inf_corr_x
        sy_inf_dn = 3*s_inf_corr_y
    if M == 32:
        sx_inf_dn = 5*s_inf_corr_x
        sy_inf_dn = 5*s_inf_corr_y
    s_inf_dn = np.append(sx_inf_dn,sy_inf_dn)

    # Blind phase noise and residual frequency offset compensation
    #N_block = 8
    #N_overlap = 4
    N_block = 64
    N_overlap = 32
    #N_block = 32
    #N_overlap = 26

    ind_1 = 0
    ind_2 = ind_1+N_block
    phi = 0
    min_dphi = -np.pi/4
    max_dphi = np.pi/4
    N_dphi = 21
    dphi_array = np.linspace(min_dphi,max_dphi,N_dphi)

    phi_array = np.array([0])
    ind_array = np.array([0])
    counter1 = 0
    while ind_2<=len(sx_inf_dn):
        s_block = sx_inf_dn[ind_1:ind_2]
        d_array_block = np.zeros(N_dphi)
        for counter, dphi in enumerate(dphi_array):
            s_block_rot = s_block*np.exp(1j*(dphi+phi))
            s_hat, dist = QAM_dem(s_block_rot,M)
            d_array_block[counter] = np.var(dist)

        #plt.figure()
        #plt.plot(d_array_block)

        d_min = min(d_array_block)
        ind_min = np.where(d_array_block==d_min)
        dphi_opt = dphi_array[ind_min[0][0]]
        phi = phi+dphi_opt
        counter1 += 1
        phi_array = np.append(phi_array, phi)
        ind_array = np.append(ind_array, int((ind_2+ind_1)/2))
        ind_1 = ind_1+N_block-N_overlap
        ind_2 = ind_1+N_block

    ind_array = np.concatenate(([0],ind_array,[len(sx_inf_dn)]))
    phi_array = np.concatenate(([0],phi_array,[phi_array[-1]]))
    phi_interp = np.interp(np.arange(len(sx_inf_dn)),ind_array,phi_array)

    if plot_flag:
        plt.figure()
        plt.plot(phi_interp)
        #print(len(phi_interp))
    sx_inf_pc = sx_inf_dn*np.exp(1j*(phi_interp))
    sy_inf_pc = sy_inf_dn*np.exp(1j*(phi_interp))

    if plot_flag:
        # Contellation
        Ni = 10
        plt.figure()
        plt.plot(np.real(sx_inf_pc[Ni:]),np.imag(sx_inf_pc[Ni:]),'.')
        plt.plot(np.real(sy_inf_pc[Ni:]),np.imag(sy_inf_pc[Ni:]),'.')
        plt.axis('square')
        plt.xlabel('In-phase [a.u.]')
        plt.ylabel('Quadrature [a.u.]')
        plt.title('After scaling correction')

    # Demapping
    s_hat_x, dist = QAM_dem(sx_inf_pc,M)
    s_hat_y, dist = QAM_dem(sy_inf_pc,M)

    s_b_x = s_b[0,:]
    s_b_y = s_b[1,:]
    #print(s_b_x)
    #print(s_b_y)

    if plot_flag:
        plt.figure()
        plt.stem(s_hat_x!=s_b_x)
        plt.stem(s_hat_y!=s_b_y)

    BER_X = np.mean(s_hat_x!=s_b_x)
    BER_Y = np.mean(s_hat_y!=s_b_y)
    BER = np.array([BER_X,BER_Y])

    return [s_inf, s_sync, s_inf_dn, BER]


# Optical receiver
def DPQAM_receiver(E_RX, s_b, P_laser = 0.01, Delta_nu = 100e3, N_sync= 128, sync_seed_X=0, sync_seed_Y=123,Freq_offset = 1e6, plot_flag = False,\
                  R=0.9, BW=4*20e9, shot_noise = True, thermal_noise = True,L=10e3,D=16e-6):

    #------------------------------------- Optical front end --------------------------------------------%

    spectrum_analysis(E_RX[0,:],t)

    # Separate polarizations
    E_RX_X = E_RX[0,:]
    E_RX_Y = E_RX[1,:]

    spectrum_analysis(E_TX[0,:],t)
    # Filter the desired channel



    # LO laser
    E_LO = single_frequency_laser(t = t, P = P_laser, Delta_nu = Delta_nu, Freq_offset = Freq_offset, X_fraction = 0.5, phi_pol = 0)

    # Separate the two polarizations of LO
    E_LO_X = E_LO[0,:]
    E_LO_Y = E_LO[1,:]

    # Process X polarization
    # Combine signal and LO
    E_1, E_2, E_3, E_4 = HybridNetwork(E_RX_X,E_LO_X)
    # Detect the outputs of 90-degree hybrid
    ipd_1 = photodiode(s=E_1,t=t,R=0.9,BW=BW,shot_noise=shot_noise,thermal_noise=thermal_noise)
    ipd_2 = photodiode(s=E_2,t=t,R=0.9,BW=BW,shot_noise=shot_noise,thermal_noise=thermal_noise)
    ipd_3 = photodiode(s=E_3,t=t,R=0.9,BW=BW,shot_noise=shot_noise,thermal_noise=thermal_noise)
    ipd_4 = photodiode(s=E_4,t=t,R=0.9,BW=BW,shot_noise=shot_noise,thermal_noise=thermal_noise)
    s_X_I = ipd_1-ipd_2   # Differential amplification
    s_X_Q = ipd_3-ipd_4   # Differential amplification

    spectrum_analysis(s_X_I,t)
    kaixo

    # Process Y polarization
    # Combine signal and LO
    E_1, E_2, E_3, E_4 = HybridNetwork(E_RX_Y,E_LO_Y)
    # Detect the outputs of 90-degree hybrid
    ipd_1 = photodiode(s=E_1,t=t,R=R,BW=BW,shot_noise=shot_noise,thermal_noise=thermal_noise)
    ipd_2 = photodiode(s=E_2,t=t,R=R,BW=BW,shot_noise=shot_noise,thermal_noise=thermal_noise)
    ipd_3 = photodiode(s=E_3,t=t,R=R,BW=BW,shot_noise=shot_noise,thermal_noise=thermal_noise)
    ipd_4 = photodiode(s=E_4,t=t,R=R,BW=BW,shot_noise=shot_noise,thermal_noise=thermal_noise)
    s_Y_I = ipd_1-ipd_2  # Differential amplification
    s_Y_Q = ipd_3-ipd_4  # Differential amplification

    # Cartesian to complex conversion
    s_rx_X = s_X_I+1j*s_X_Q
    s_rx_Y = s_Y_I+1j*s_Y_Q

    #print(np.shape(s_Y_I))

    m,n = np.shape(s_Y_I)
    s_rec = np.zeros((2,n),dtype=complex)

    #print(np.shape(s_Y_I))
    #print(np.shape(s_rec))
    #print(np.shape(s_rx_X))

    s_rec[0,:] = s_rx_X
    s_rec[1,:] = s_rx_Y


    #QAM_receiver_DP(s_rec, t = t, M =M, SpS = SpS, N_sync = N_sync, N_inf = N_inf,sync_seed_X=0,sync_seed_Y=123,\
    #                RollOff = RollOff,ts = ts,s_b=s_b[0,:],plot_flag = plot_flag)
    s_inf, s_sync, s_inf_dn, BER = QAM_receiver_DP(s_rec, t = t, M =M, SpS = SpS, N_sync = N_sync, N_inf = N_inf,sync_seed_X=0,sync_seed_Y=123,\
                    RollOff = RollOff,ts = ts,s_b=s_b,plot_flag = plot_flag,L=L,D=D)
    return BER

"""## 6.2 B2B digital coherent system"""

plt.close('all')

# General Parameters
M = 16                 # Number of points in the constellation
SpS = 16               # Number of samples per symbol
RollOff = 0.2          # Roll-off factor
BaudRate = 14e9        # Baudrate in Sps
Tsym = 1/BaudRate      # Symbol peiod in s
ts = Tsym/SpS          # Sampling peiod
N_zeros_init = 100     # Number of initial zeros
N_sync = 256           # Number of synchronization symbols
N_inf = 4*4096           # Number of information symbols (payload)
N_zeros_final = 100    # Number of final zeros
sync_seed_X=0          # Seed for the X polarization
sync_seed_Y=123        # Seed for the Y polarization

# Configuration of the optical blocks
P_laser_TX = 0.01      # Transmitter laser power in W
Delta_nu_TX = 100e3    # Transmitter laser linewidth in Hz
P_laser_RX = 0.01      # Transmitter laser power in W
Delta_nu_RX = 100e3    # Transmitter laser linewidth in Hz
Freq_offset_TX = 0+75e9     # Offset frequency of the transmitter laser in Hz
Freq_offset_RX = 55e6+75e9  # Offset frequency of the transmitter laser in Hz
ind_mod = 0.1          # Modulation index

L = 100e3             # Fiber length in [m]
alpha_dB = 0.2e-3     # Fiber attenuation in dB/m
D = 16e-6             # Dispersion in [s/m^2]
n2= 2.6e-20         # Nonlinear coeffient in m^2/W
DeltaL = 1e3          # Fiber segment in m
lambda0 = 1550e-9     # Nominal wavelength in m
Aeff = 80e-12         # Effective modal area in m^2
SoP_rotation = True   # Activate SoP rotation

G_edfa_dB = 26
NF_dB = 5
t, E_TX, E_carrier, s_tx, s_b = DPQAM_transmitter(M = M, SpS = SpS, RollOff = RollOff, \
                ts = ts, sync_seed_X=0,sync_seed_Y=123,N_sync = 256,N_inf = N_inf,N_zeros_init=N_zeros_init,\
                N_zeros_final=N_zeros_final,ind_mod = ind_mod,Delta_nu=Delta_nu_TX,Freq_offset=Freq_offset_TX,\
                plot_flag = False)
# Visualization of the spectrum
spectrum_analysis(E_TX[0,:],t)

# Channel
E_amp = EDFA(E_TX,t,G_edfa_dB,NF_dB,lambda0=1550e-9)
E_RX = fiber(E_amp,t,L,DeltaL,D,lambda0,alpha_dB,n2,Aeff,SoP_rotation) # Output field

# Optical receiver
BER = DPQAM_receiver(E_RX,s_b, P_laser = P_laser_RX, Delta_nu = Delta_nu_RX, N_sync = N_sync, sync_seed_X=0,sync_seed_Y=123,Freq_offset = Freq_offset_RX, \
                     plot_flag = False, shot_noise = True, thermal_noise = True,L=L,D=D)
print('The BER of the X component is:',BER[0])
print('The BER of the X component is:',BER[1])

"""Ex. 1: Modify the code in order to set the launched optical power (consider both polarizations)."""

plt.close('all')

# General Parameters
M = 16                 # Number of points in the constellation
SpS = 16               # Number of samples per symbol
RollOff = 0.2          # Roll-off factor
BaudRate = 4*14e9        # Baudrate in Sps
Tsym = 1/BaudRate      # Symbol peiod in s
ts = Tsym/SpS          # Sampling peiod
N_zeros_init = 100     # Number of initial zeros
N_sync = 256           # Number of synchronization symbols
N_inf = 4*4096           # Number of information symbols (payload)
N_zeros_final = 100    # Number of final zeros
sync_seed_X=0          # Seed for the X polarization
sync_seed_Y=123        # Seed for the Y polarization

# Configuration of the optical blocks
P_laser_TX = 0.01      # Transmitter laser power in W
Delta_nu_TX = 100e3    # Transmitter laser linewidth in Hz
P_laser_RX = 0.01      # Transmitter laser power in W
Delta_nu_RX = 100e3    # Transmitter laser linewidth in Hz
Freq_offset_TX = 75e9     # Offset frequency of the transmitter laser in Hz
Freq_offset_RX = 55e6+75e9  # Offset frequency of the transmitter laser in Hz
ind_mod = 0.1          # Modulation index

L = 120e3             # Fiber length in [m]
alpha_dB = 0.2e-3     # Fiber attenuation in dB/m
D = 16e-6             # Dispersion in [s/m^2]
n2= 2.6e-20           # Nonlinear coeffient in m^2/W
DeltaL = 1e3          # Fiber segment in m
lambda0 = 1550e-9     # Nominal wavelength in m
Aeff = 80e-12         # Effective modal area in m^2
SoP_rotation = True   # Activate SoP rotation
#G_edfa_dB = 24
NF_dB = 5
P_LOP = 0.002          # Launch optical power in W

t, E_TX, E_carrier, s_tx, s_b = DPQAM_transmitter(M = M, SpS = SpS, RollOff = RollOff, \
                ts = ts, sync_seed_X=0,sync_seed_Y=123,N_sync = 256,N_inf = N_inf,N_zeros_init=N_zeros_init,\
                N_zeros_final=N_zeros_final,ind_mod = ind_mod,Delta_nu=Delta_nu_TX,Freq_offset=Freq_offset_TX,\
                plot_flag = True)

# Visualization of the spectrum
spectrum_analysis(E_TX[0,:],t)

P_aux = np.mean((np.abs(E_TX[0,:]))**2)+np.mean((np.abs(E_TX[1,:]))**2)
#G_edfa = P_LOP/P_aux
G_edfa_dB = 10*np.log10(P_LOP/P_aux)
print('The required gain is:',G_edfa_dB,'dB')
E_LOP = EDFA(E_TX,t,G_edfa_dB,NF_dB,lambda0=1550e-9)
P_aux_1 = np.mean((np.abs(E_LOP[0,:]))**2)+np.mean((np.abs(E_LOP[1,:]))**2)
#print(P_aux_1)

# Channel
E_RX = fiber(E_LOP,t,L,DeltaL,D,lambda0,alpha_dB,n2,Aeff,SoP_rotation) # Output field

# Optical receiver
BER = DPQAM_receiver(E_RX,s_b, P_laser = P_laser_RX, Delta_nu = Delta_nu_RX, N_sync = N_sync, sync_seed_X=0,sync_seed_Y=123,Freq_offset = Freq_offset_RX, \
                     plot_flag = True, shot_noise = True, thermal_noise = True,L=L,D=D)
print('The BER of the X component is:',BER[0])
print('The BER of the Y component is:',BER[1])

"""Ex. 2: Make a sweep on the launched optical power and find the optimum power level. Explain the behavior."""

plt.close('all')

# General Parameters
M = 16                 # Number of points in the constellation
SpS = 16               # Number of samples per symbol
RollOff = 0.2          # Roll-off factor
BaudRate = 4*14e9        # Baudrate in Sps
Tsym = 1/BaudRate      # Symbol period in s
ts = Tsym/SpS          # Sampling peiod
N_zeros_init = 100     # Number of initial zeros
N_sync = 256           # Number of synchronization symbols
N_inf = 4*4096         # Number of information symbols (payload)
N_zeros_final = 100    # Number of final zeros
sync_seed_X=0          # Seed for the X polarization
sync_seed_Y=123        # Seed for the Y polarization

# Configuration of the optical blocks
P_laser_TX = 0.01      # Transmitter laser power in W
Delta_nu_TX = 100e3    # Transmitter laser linewidth in Hz
P_laser_RX = 0.01      # Transmitter laser power in W
Delta_nu_RX = 100e3    # Transmitter laser linewidth in Hz
Freq_offset_TX = 0     # Offset frequency of the transmitter laser in Hz
Freq_offset_RX = 55e6  # Offset frequency of the transmitter laser in Hz
ind_mod = 0.1          # Modulation index

L = 100e3              # Fiber length in [m]
alpha_dB = 0.2e-3      # Fiber attenuation in dB/m
D = 16e-6              # Dispersion in [s/m^2]
n2= 2.6e-20            # Nonlinear coeffient in m^2/W
DeltaL = 1e3           # Fiber segment in m
lambda0 = 1550e-9      # Nominal wavelength in m
Aeff = 80e-12          # Effective modal area in m^2
SoP_rotation = True    # Activate SoP rotation
#G_edfa_dB = 24
NF_dB = 5

#P_LOP_array = np.arange(0.001,0.01,0.00025)     # Launch optical power in W
P_LOP_array = np.arange(0.001,0.01,0.001)     # Launch optical power in W

BER_X_array = np.zeros(np.shape(P_LOP_array))
BER_Y_array = np.zeros(np.shape(P_LOP_array))
for counter, P_LOP in enumerate(P_LOP_array):
    print('Processing',counter,'of',len(P_LOP_array))
    plt.close('all')
    t, E_TX, E_carrier, s_tx, s_b = DPQAM_transmitter(M = M, SpS = SpS, RollOff = RollOff, \
                ts = ts, sync_seed_X=0,sync_seed_Y=123,N_sync = 256,N_inf = N_inf,N_zeros_init=N_zeros_init,\
                N_zeros_final=N_zeros_final,ind_mod = ind_mod,Delta_nu=Delta_nu_TX,Freq_offset=Freq_offset_TX,\
                plot_flag = True)
    # Visualization of the spectrum
    #spectrum_analysis(E_TX[0,:],t)
    P_aux = np.mean((np.abs(E_TX[0,:]))**2)+np.mean((np.abs(E_TX[0,:]))**2)
    G_edfa_dB = 10*np.log10(P_LOP/P_aux)
    print('The required gain is:',G_edfa_dB,'dB')
    E_LOP = EDFA(E_TX,t,G_edfa_dB,NF_dB,lambda0=1550e-9)

    # Channel
    E_RX = fiber(E_LOP,t,L,DeltaL,D,lambda0,alpha_dB,n2,Aeff,SoP_rotation) # Output field

    # Optical receiver
    BER = DPQAM_receiver(E_RX,s_b, P_laser = P_laser_RX, Delta_nu = Delta_nu_RX, N_sync = N_sync, sync_seed_X=0,sync_seed_Y=123,Freq_offset = Freq_offset_RX, \
                     plot_flag = False, shot_noise = True, thermal_noise = True,L=L,D=D)
    print('\tThe BER of the X component is:',BER[0])
    print('\tThe BER of the Y component is:',BER[1])
    BER_X_array[counter] = BER[0]
    BER_Y_array[counter] = BER[1]
plt.figure()
plt.plot(BER_X_array)
plt.plot(BER_Y_array)

plt.figure()
plt.plot(BER_X_array)
plt.plot(BER_Y_array)
plt.plot((BER_X_array+BER_Y_array)/2)
plt.xscale('log')
plt.yscale('log')

plt.close('all')

# General Parameters
M = 16                 # Number of points in the constellation
SpS = 16               # Number of samples per symbol
RollOff = 0.2          # Roll-off factor
BaudRate = 4*14e9        # Baudrate in Sps
Tsym = 1/BaudRate      # Symbol period in s
ts = Tsym/SpS          # Sampling peiod
N_zeros_init = 100     # Number of initial zeros
N_sync = 256           # Number of synchronization symbols
N_inf = 4*4096         # Number of information symbols (payload)
N_zeros_final = 100    # Number of final zeros
sync_seed_X=0          # Seed for the X polarization
sync_seed_Y=123        # Seed for the Y polarization

# Configuration of the optical blocks
P_laser_TX = 0.01      # Transmitter laser power in W
Delta_nu_TX = 100e3    # Transmitter laser linewidth in Hz
P_laser_RX = 0.01      # Transmitter laser power in W
Delta_nu_RX = 100e3    # Transmitter laser linewidth in Hz
Freq_offset_RX = 55e6  # Offset frequency of the transmitter laser in Hz
ind_mod = 0.1          # Modulation index

# Fiber parameters
L = 150e3              # Fiber length in [m]
alpha_dB = 0.2e-3      # Fiber attenuation in dB/m
D = 16e-6              # Dispersion in [s/m^2]
n2= 2.6e-20            # Nonlinear coeffient in m^2/W
DeltaL = 1e3           # Fiber segment in m
lambda0 = 1550e-9      # Nominal wavelength in m
Aeff = 80e-12          # Effective modal area in m^2
SoP_rotation = True    # Activate SoP rotation
#G_edfa_dB = 24
NF_dB = 5

# Frequency parameters
delta_f = 75e9
Freq_offset_TX0 = -3*delta_f/2
Freq_offset_TX1 = -delta_f/2
Freq_offset_TX2 = delta_f/2
Freq_offset_TX3 = 3*delta_f/2

Freq_offset_RX = 55e6
Freq_offset_RX0 = Freq_offset_TX0+Freq_offset_RX
Freq_offset_RX1 = Freq_offset_TX1+Freq_offset_RX
Freq_offset_RX2 = Freq_offset_TX2+Freq_offset_RX
Freq_offset_RX3 = Freq_offset_TX3+Freq_offset_RX

t, E_TX_0, E_carrier, s_tx, s_b = DPQAM_transmitter(M = M, SpS = SpS, RollOff = RollOff, \
                ts = ts, sync_seed_X=0,sync_seed_Y=123,N_sync = 256,N_inf = N_inf,N_zeros_init=N_zeros_init,\
                N_zeros_final=N_zeros_final,ind_mod = ind_mod,Delta_nu=Delta_nu_TX,Freq_offset=Freq_offset_TX0,\
                plot_flag = True)

t, E_TX_1, E_carrier, s_tx, s_b = DPQAM_transmitter(M = M, SpS = SpS, RollOff = RollOff, \
                ts = ts, sync_seed_X=0,sync_seed_Y=123,N_sync = 256,N_inf = N_inf,N_zeros_init=N_zeros_init,\
                N_zeros_final=N_zeros_final,ind_mod = ind_mod,Delta_nu=Delta_nu_TX,Freq_offset=Freq_offset_TX1,\
                plot_flag = True)

t, E_TX_2, E_carrier, s_tx, s_b = DPQAM_transmitter(M = M, SpS = SpS, RollOff = RollOff, \
                ts = ts, sync_seed_X=0,sync_seed_Y=123,N_sync = 256,N_inf = N_inf,N_zeros_init=N_zeros_init,\
                N_zeros_final=N_zeros_final,ind_mod = ind_mod,Delta_nu=Delta_nu_TX,Freq_offset=Freq_offset_TX2,\
                plot_flag = True)

t, E_TX_3, E_carrier, s_tx, s_b = DPQAM_transmitter(M = M, SpS = SpS, RollOff = RollOff, \
                ts = ts, sync_seed_X=0,sync_seed_Y=123,N_sync = 256,N_inf = N_inf,N_zeros_init=N_zeros_init,\
                N_zeros_final=N_zeros_final,ind_mod = ind_mod,Delta_nu=Delta_nu_TX,Freq_offset=Freq_offset_TX3,\
                plot_flag = True)

E_TX = E_TX_0+E_TX_1+E_TX_2+E_TX_3

# Visualization of the spectrum
spectrum_analysis(E_TX[0,:],t)

E_RX = fiber(E_TX,t,L,DeltaL,D,lambda0,alpha_dB,n2,Aeff,SoP_rotation) # Output fielf

spectrum_analysis(E_RX[0,:],t)

print(t)

def optical_filter(s,t,f0,BW):
    ts = t[1]-t[0]                       # Sampling period in s
    fs = 1/ts                            # Sampling frequancy in Hz
    Deltaf = 1/(ts*len(t))               # Frequency resolution in Hz
    f = np.arange(len(t))*Deltaf-fs/2    # Frequency vector in Hz
    ind1 = np.where(f<(f0-BW/2))
    ind2 = np.where(f<(f0+BW/2))
    #print(ind1[0][-1])
    #print(ind2[0][-1])
    #print(f[ind1[0][-1]]/1e9)
    #print(f[ind2[0][-1]]/1e9)

    S = np.fft.fftshift(np.fft.fft(s))

    H = np.zeros(len(f))
    H[ind1[0][-1]:ind2[0][-1]]=1
    Sf = S*H

    #plt.figure()
    #plt.plot(f,np.abs(S[0,:]))
    #plt.plot(f,np.abs(Sf[0,:]))

    sf = np.fft.ifft(np.fft.ifftshift(Sf))

    return sf

# Optical receiver
def DPQAM_receiver(E_RX, s_b, P_laser = 0.01, Delta_nu = 100e3, N_sync= 128, sync_seed_X=0, sync_seed_Y=123,Freq_offset = 1e6, plot_flag = False,\
                  R=0.9, BW=4*20e9, shot_noise = True, thermal_noise = True,L=10e3,D=16e-6):

    #------------------------------------- Optical front end --------------------------------------------%

    spectrum_analysis(E_RX[0,:],t)

    E_RXf = optical_filter(E_RX,t,f0 = Freq_offset, BW = BW)

    spectrum_analysis(E_RXf[0,:],t)

    # Separate polarizations
    E_RX_X = E_RXf[0,:]
    E_RX_Y = E_RXf[1,:]

    spectrum_analysis(E_RX_X,t)



    # LO laser
    E_LO = single_frequency_laser(t = t, P = P_laser, Delta_nu = Delta_nu, Freq_offset = Freq_offset, X_fraction = 0.5, phi_pol = 0)

    spectrum_analysis(E_LO[0,:],t)


    # Separate the two polarizations of LO
    E_LO_X = E_LO[0,:]
    E_LO_Y = E_LO[1,:]

    # Process X polarization
    # Combine signal and LO
    E_1, E_2, E_3, E_4 = HybridNetwork(E_RX_X,E_LO_X)
    # Detect the outputs of 90-degree hybrid

    spectrum_analysis(E_1,t)
    ipd_1 = photodiode(s=E_1,t=t,R=0.9,BW=BW,shot_noise=shot_noise,thermal_noise=thermal_noise)

    #plt.figure()
    #plt.plot(abs(ipd_1))
    ipd_2 = photodiode(s=E_2,t=t,R=0.9,BW=BW,shot_noise=shot_noise,thermal_noise=thermal_noise)
    ipd_3 = photodiode(s=E_3,t=t,R=0.9,BW=BW,shot_noise=shot_noise,thermal_noise=thermal_noise)
    ipd_4 = photodiode(s=E_4,t=t,R=0.9,BW=BW,shot_noise=shot_noise,thermal_noise=thermal_noise)
    s_X_I = ipd_1-ipd_2   # Differential amplification
    s_X_Q = ipd_3-ipd_4   # Differential amplification

    #S_aux = np.fft.fftshift(np.fft.fft(s_X_I))
    #plt.figure()
    #plt.plot(np.abs(S_aux))
    #plt.plot(s_X_I)

    # Process Y polarization
    # Combine signal and LO
    E_1, E_2, E_3, E_4 = HybridNetwork(E_RX_Y,E_LO_Y)
    # Detect the outputs of 90-degree hybrid
    ipd_1 = photodiode(s=E_1,t=t,R=R,BW=BW/2,shot_noise=shot_noise,thermal_noise=thermal_noise)
    ipd_2 = photodiode(s=E_2,t=t,R=R,BW=BW/2,shot_noise=shot_noise,thermal_noise=thermal_noise)
    ipd_3 = photodiode(s=E_3,t=t,R=R,BW=BW/2,shot_noise=shot_noise,thermal_noise=thermal_noise)
    ipd_4 = photodiode(s=E_4,t=t,R=R,BW=BW/2,shot_noise=shot_noise,thermal_noise=thermal_noise)
    s_Y_I = ipd_1-ipd_2  # Differential amplification
    s_Y_Q = ipd_3-ipd_4  # Differential amplification

    # Cartesian to complex conversion
    s_rx_X = s_X_I+1j*s_X_Q
    s_rx_Y = s_Y_I+1j*s_Y_Q

    #print(np.shape(s_Y_I))

    m,n = np.shape(s_Y_I)
    s_rec = np.zeros((2,n),dtype=complex)

    #print(np.shape(s_Y_I))
    #print(np.shape(s_rec))
    #print(np.shape(s_rx_X))

    s_rec[0,:] = s_rx_X
    s_rec[1,:] = s_rx_Y

    #QAM_receiver_DP(s_rec, t = t, M =M, SpS = SpS, N_sync = N_sync, N_inf = N_inf,sync_seed_X=0,sync_seed_Y=123,\
    #                RollOff = RollOff,ts = ts,s_b=s_b[0,:],plot_flag = plot_flag)
    s_inf, s_sync, s_inf_dn, BER = QAM_receiver_DP(s_rec, t = t, M =M, SpS = SpS, N_sync = N_sync, N_inf = N_inf,sync_seed_X=0,sync_seed_Y=123,\
                    RollOff = RollOff,ts = ts,s_b=s_b,plot_flag = plot_flag,L=L,D=D)
    return BER

# test label
BER = DPQAM_receiver(E_RX,s_b, P_laser = P_laser_RX, Delta_nu = Delta_nu_RX, N_sync = N_sync, sync_seed_X=0,sync_seed_Y=123,Freq_offset = Freq_offset_RX0, \
                     plot_flag = True, shot_noise = True, thermal_noise = True,L=L,D=D)





















#spectrum_analysis(E_RX[0,:],t)

#E_RXf = optical_filter(E_RX,t,f0=-3/2*75e9,BW=75e9)
#spectrum_analysis(E_RXf[0,:],t)

#E_RXf = optical_filter(E_RX,t,f0=-1/2*75e9,BW=75e9)
#spectrum_analysis(E_RXf[0,:],t)

#E_RXf = optical_filter(E_RX,t,f0=1/2*75e9,BW=75e9)
#spectrum_analysis(E_RXf[0,:],t)

#E_RXf = optical_filter(E_RX,t,f0=3/2*75e9,BW=75e9)
#spectrum_analysis(E_RXf[0,:],t)

# Optical receiver channel 1

#E_RXf = optical_filter(E_RX,t,f0=Freq_offset_RX0,BW=75e9)
#spectrum_analysis(E_RXf[0,:],t)

print(t)
BER = DPQAM_receiver(E_RX,s_b, P_laser = P_laser_RX, Delta_nu = Delta_nu_RX, N_sync = N_sync, sync_seed_X=0,sync_seed_Y=123,Freq_offset = Freq_offset_RX0, \
                     plot_flag = True, shot_noise = True, thermal_noise = True,L=L,D=D)

print('\tThe BER of the X component is (channel0):',BER[0])
print('\tThe BER of the Y component is:',BER[1])
BER_X_array[counter] = BER[0]
BER_Y_array[counter] = BER[1]









# Optical receiver
BER0 = DPQAM_receiver(E_RX,s_b, P_laser = P_laser_RX, Delta_nu = Delta_nu_RX, N_sync = N_sync, sync_seed_X=0,sync_seed_Y=123,Freq_offset = Freq_offset_RX0, \
                     plot_flag = True, shot_noise = True, thermal_noise = True,L=L,D=D)
print('\tThe BER of the X component is (channel 0):',BER0[0])
print('\tThe BER of the Y component is (channel 0):',BER0[1])

plt.figure()
plt.semilogy(P_LOP_array*1000,BER_X_array)
plt.semilogy(P_LOP_array*1000,BER_Y_array)
plt.semilogy(P_LOP_array*1000,(BER_X_array+BER_Y_array)/2)
plt.xlabel('Launched optical power [mW]')
plt.ylabel('BER')

"""Ex. 3: Make a sweep on the length of the fiber and find the maximum achievable length to ensure a BER of $10^{-3}$."""

plt.close('all')

# General Parameters
M = 16                 # Number of points in the constellation
SpS = 16               # Number of samples per symbol
RollOff = 0.2          # Roll-off factor
BaudRate = 14e9        # Baudrate in Sps
Tsym = 1/BaudRate      # Symbol peiod in s
ts = Tsym/SpS          # Sampling peiod
N_zeros_init = 100     # Number of initial zeros
N_sync = 256           # Number of synchronization symbols
N_inf = 4*4096           # Number of information symbols (payload)
N_zeros_final = 100    # Number of final zeros
sync_seed_X=0          # Seed for the X polarization
sync_seed_Y=123        # Seed for the Y polarization

# Configuration of the optical blocks
P_laser_TX = 0.01      # Transmitter laser power in W
Delta_nu_TX = 100e3    # Transmitter laser linewidth in Hz
P_laser_RX = 0.01      # Transmitter laser power in W
Delta_nu_RX = 100e3    # Transmitter laser linewidth in Hz
Freq_offset_TX = 0     # Offset frequency of the transmitter laser in Hz
Freq_offset_RX = 55e6  # Offset frequency of the transmitter laser in Hz
ind_mod = 0.1          # Modulation index

alpha_dB = 0.2e-3     # Fiber attenuation in dB/m
D = 16e-6             # Dispersion in [s/m^2]
n2= 2.6e-20           # Nonlinear coeffient in m^2/W
DeltaL = 1e3          # Fiber segment in m
lambda0 = 1550e-9     # Nominal wavelength in m
Aeff = 80e-12         # Effective modal area in m^2
SoP_rotation = True   # Activate SoP rotation
#G_edfa_dB = 24
NF_dB = 5
P_LOP = 0.004         # LOP obtained from the previous code

L_array = np.arange(100e3,210e3,10e3)     # Launch optical power in W
BER_X_array_L = np.zeros(np.shape(L_array))
BER_Y_array_L = np.zeros(np.shape(L_array))
for counter, L in enumerate(L_array):
    print('Processing',counter,'of',len(L_array))
    plt.close('all')
    t, E_TX, E_carrier, s_tx, s_b = DPQAM_transmitter(M = M, SpS = SpS, RollOff = RollOff, \
                ts = ts, sync_seed_X=0,sync_seed_Y=123,N_sync = 256,N_inf = N_inf,N_zeros_init=N_zeros_init,\
                N_zeros_final=N_zeros_final,ind_mod = ind_mod,Delta_nu=Delta_nu_TX,Freq_offset=Freq_offset_TX,\
                plot_flag = True)
    # Visualization of the spectrum
    #spectrum_analysis(E_TX[0,:],t)
    P_aux = np.mean((np.abs(E_TX[0,:]))**2)+np.mean((np.abs(E_TX[0,:]))**2)
    G_edfa_dB = 10*np.log10(P_LOP/P_aux)
    print('The required gain is:',G_edfa_dB,'dB')
    E_LOP = EDFA(E_TX,t,G_edfa_dB,NF_dB,lambda0=1550e-9)

    # Channel
    E_RX = fiber(E_LOP,t,L,DeltaL,D,lambda0,alpha_dB,n2,Aeff,SoP_rotation) # Output field

    # Optical receiver
    BER = DPQAM_receiver(E_RX,s_b, P_laser = P_laser_RX, Delta_nu = Delta_nu_RX, N_sync = N_sync, sync_seed_X=0,sync_seed_Y=123,Freq_offset = Freq_offset_RX, \
                     plot_flag = False, shot_noise = True, thermal_noise = True,L=L,D=D)
    print('\tThe BER of the X component is:',BER[0])
    print('\tThe BER of the Y component is:',BER[1])
    BER_X_array_L[counter] = BER[0]
    BER_Y_array_L[counter] = BER[1]

plt.figure()
plt.semilogy(L_array/1000,BER_X_array_L)
plt.semilogy(L_array/1000,BER_Y_array_L)
plt.xlabel('Link length [km]')
plt.ylabel('BER')
plt.grid('on')

"""Ex. 4: Extend the code to consider a multi-span link."""

plt.close('all')

# General Parameters
M = 16                 # Number of points in the constellation
SpS = 16               # Number of samples per symbol
RollOff = 0.2          # Roll-off factor
BaudRate = 14e9        # Baudrate in Sps
Tsym = 1/BaudRate      # Symbol peiod in s
ts = Tsym/SpS          # Sampling peiod
N_zeros_init = 100     # Number of initial zeros
N_sync = 256           # Number of synchronization symbols
N_inf = 4*4096           # Number of information symbols (payload)
N_zeros_final = 100    # Number of final zeros
sync_seed_X=0          # Seed for the X polarization
sync_seed_Y=123        # Seed for the Y polarization

# Configuration of the optical blocks
P_laser_TX = 0.01      # Transmitter laser power in W
Delta_nu_TX = 100e3    # Transmitter laser linewidth in Hz
P_laser_RX = 0.01      # Transmitter laser power in W
Delta_nu_RX = 100e3    # Transmitter laser linewidth in Hz
Freq_offset_TX = 0     # Offset frequency of the transmitter laser in Hz
Freq_offset_RX = 55e6  # Offset frequency of the transmitter laser in Hz
ind_mod = 0.1          # Modulation index

alpha_dB = 0.2e-3     # Fiber attenuation in dB/m
D = 16e-6             # Dispersion in [s/m^2]
n2= 2.6e-20           # Nonlinear coeffient in m^2/W
DeltaL = 1e3          # Fiber segment in m
lambda0 = 1550e-9     # Nominal wavelength in m
Aeff = 80e-12         # Effective modal area in m^2
SoP_rotation = True   # Activate SoP rotation
#G_edfa_dB = 24
NF_dB = 5
P_LOP = 0.002          # Launch optical power in W

N_span = 5
L_span = 50e3
L = N_span*L_span

t, E_TX, E_carrier, s_tx, s_b = DPQAM_transmitter(M = M, SpS = SpS, RollOff = RollOff, \
                ts = ts, sync_seed_X=0,sync_seed_Y=123,N_sync = 256,N_inf = N_inf,N_zeros_init=N_zeros_init,\
                N_zeros_final=N_zeros_final,ind_mod = ind_mod,Delta_nu=Delta_nu_TX,Freq_offset=Freq_offset_TX,\
                plot_flag = True)
# Visualization of the spectrum
#spectrum_analysis(E_TX[0,:],t)
P_aux = np.mean((np.abs(E_TX[0,:]))**2)+np.mean((np.abs(E_TX[0,:]))**2)
G_edfa_dB = 10*np.log10(P_LOP/P_aux)
print('The required gain is:',G_edfa_dB,'dB')
E_TX = EDFA(E_TX,t,G_edfa_dB,NF_dB,lambda0=1550e-9)

# Multispan channel
E_inline = E_TX
G_edfa_dB = alpha_dB*L_span

print(G_edfa_dB)

for aux in range(N_span):
    print('Signal propagation in span number',aux)
    E_inline = fiber(E_inline,t,L_span,DeltaL,D,lambda0,alpha_dB,n2,Aeff,SoP_rotation) # Output field
    E_inline = EDFA(E_inline,t,G_edfa_dB,NF_dB,lambda0=1550e-9)
E_RX = E_inline

# Optical receiver
BER = DPQAM_receiver(E_RX,s_b, P_laser = P_laser_RX, Delta_nu = Delta_nu_RX, N_sync = N_sync, sync_seed_X=0,sync_seed_Y=123,Freq_offset = Freq_offset_RX, \
                     plot_flag = True, shot_noise = True, thermal_noise = True,L=L,D=D)
print('The BER of the X component is:',BER[0])
print('The BER of the Y component is:',BER[1])

plt.close('all')

# General Parameters
M = 16                 # Number of points in the constellation
SpS = 16               # Number of samples per symbol
RollOff = 0.2          # Roll-off factor
BaudRate = 14e9        # Baudrate in Sps
Tsym = 1/BaudRate      # Symbol peiod in s
ts = Tsym/SpS          # Sampling peiod
N_zeros_init = 100     # Number of initial zeros
N_sync = 256           # Number of synchronization symbols
N_inf = 4*4096           # Number of information symbols (payload)
N_zeros_final = 100    # Number of final zeros
sync_seed_X=0          # Seed for the X polarization
sync_seed_Y=123        # Seed for the Y polarization

# Configuration of the optical blocks
P_laser_TX = 0.01      # Transmitter laser power in W
Delta_nu_TX = 100e3    # Transmitter laser linewidth in Hz
P_laser_RX = 0.01      # Transmitter laser power in W
Delta_nu_RX = 100e3    # Transmitter laser linewidth in Hz
Freq_offset_TX = 0     # Offset frequency of the transmitter laser in Hz
Freq_offset_RX = 55e6  # Offset frequency of the transmitter laser in Hz
ind_mod = 0.1          # Modulation index

alpha_dB = 0.2e-3     # Fiber attenuation in dB/m
D = 16e-6             # Dispersion in [s/m^2]
n2= 2.6e-20           # Nonlinear coeffient in m^2/W
DeltaL = 1e3          # Fiber segment in m
lambda0 = 1550e-9     # Nominal wavelength in m
Aeff = 80e-12         # Effective modal area in m^2
SoP_rotation = True   # Activate SoP rotation
#G_edfa_dB = 24
NF_dB = 5
P_LOP = 0.002          # Launch optical power in W

N_span = 7
L_span = 40e3
L = N_span*L_span

t, E_TX, E_carrier, s_tx, s_b = DPQAM_transmitter(M = M, SpS = SpS, RollOff = RollOff, \
                ts = ts, sync_seed_X=0,sync_seed_Y=123,N_sync = 256,N_inf = N_inf,N_zeros_init=N_zeros_init,\
                N_zeros_final=N_zeros_final,ind_mod = ind_mod,Delta_nu=Delta_nu_TX,Freq_offset=Freq_offset_TX,\
                plot_flag = True)
# Visualization of the spectrum
#spectrum_analysis(E_TX[0,:],t)
P_aux = np.mean((np.abs(E_TX[0,:]))**2)+np.mean((np.abs(E_TX[0,:]))**2)
G_edfa_dB = 10*np.log10(P_LOP/P_aux)
print('The required gain is:',G_edfa_dB,'dB')
E_TX = EDFA(E_TX,t,G_edfa_dB,NF_dB,lambda0=1550e-9)

# Multispan channel
E_inline = E_TX
G_edfa_dB = alpha_dB*L_span

print(G_edfa_dB)
BER_X_span = np.zeros(N_span)
BER_Y_span = np.zeros(N_span)
for counter, aux in enumerate(range(N_span)):
    print('Signal propagation in span number',aux)
    E_inline = fiber(E_inline,t,L_span,DeltaL,D,lambda0,alpha_dB,n2,Aeff,SoP_rotation) # Output field
    E_inline = EDFA(E_inline,t,G_edfa_dB,NF_dB,lambda0=1550e-9)
    E_RX = E_inline

    # Optical receiver
    BER = DPQAM_receiver(E_RX,s_b, P_laser = P_laser_RX, Delta_nu = Delta_nu_RX, N_sync = N_sync, sync_seed_X=0,sync_seed_Y=123,Freq_offset = Freq_offset_RX, \
                     plot_flag = True, shot_noise = True, thermal_noise = True,L=L_span*(aux+1),D=D)
    print('The BER of the X component is:',BER[0])
    print('The BER of the Y component is:',BER[1])
    BER_X_span[counter] = BER[0]
    BER_Y_span[counter] = BER[1]

plt.figure()
plt.semilogy(np.arange(N_span)+1,BER_X_span)
plt.semilogy(np.arange(N_span)+1,BER_Y_span)
plt.xlabel('Number of spans')
plt.ylabel('BER')
plt.grid('on')

