from QAM_transmitter import QAM_transmitter
from QAM_receiver import QAM_receiver
from QAM_receiver_DP import QAM_receiver_DP
from DPQAM_receiver import DPQAM_receiver
from single_frequency_laser import single_frequency_laser
from MZM import MZM
from HybridNetwork import HybridNetwork
from photodiode import photodiode
from fiber import fiber
from EDFA import EDFA
from constellation_analysis import constellation_analysis
from spectrum_analysis import spectrum_analysis
from DPQAM_transmitter import DPQAM_transmitter
from optical_filter import optical_filter

# -*- coding: utf-8 -*-
"""6_DigitalCoherentSystem_DP_fiber_solved.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/120eO2wUnIRLB09moO0Dr9X54yWaz6gin

# 6. Simulation of a dual-polarization digital coherent system

In this notebook, you will simulate a complete communication system employing QAM modulation formats with dual polarization.

In particular you will learn some important concepts, including:
- QAM modulation and demodulation
- Time synchronization through correlation
- Phase alignment
- Filtering

The simulation includes lasers, modulators, and photodetectors.

## 6.0 Reset the variables and configure the environment:
"""

# Commented out IPython magic to ensure Python compatibility.
#%reset
import numpy as np
import matplotlib.pyplot as plt
# %matplotlib qt

plt.close('all')

# General Parameters
M = 16                 # Number of points in the constellation
SpS = 16               # Number of samples per symbol
RollOff = 0.2          # Roll-off factor
BaudRate = 14e9        # Baudrate in Sps
Tsym = 1/BaudRate      # Symbol peiod in s
ts = Tsym/SpS          # Sampling peiod
N_zeros_init = 100     # Number of initial zeros
N_sync = 256           # Number of synchronization symbols
N_inf = 4*4096           # Number of information symbols (payload)
N_zeros_final = 100    # Number of final zeros
sync_seed_X=0          # Seed for the X polarization
sync_seed_Y=123        # Seed for the Y polarization

# Configuration of the optical blocks

Delta_nu_TX = 100e3    # Transmitter laser linewidth in Hz
P_laser_RX = 0.01      # Transmitter laser power in W
Delta_nu_RX = 100e3    # Transmitter laser linewidth in Hz
Freq_offset_TX = 0+75e9     # Offset frequency of the transmitter laser in Hz
Freq_offset_RX = 55e6+75e9  # Offset frequency of the transmitter laser in Hz
ind_mod = 0.1          # Modulation index

P_laser_TX = 0.01      # Transmitter laser power in W
L = 100e3             # Fiber length in [m]
alpha_dB = 0.2e-3     # Fiber attenuation in dB/m
D = 16e-6             # Dispersion in [s/m^2]
n2= 2.6e-20         # Nonlinear coeffient in m^2/W
DeltaL = 1e3          # Fiber segment in m
lambda0 = 1550e-9     # Nominal wavelength in m
Aeff = 80e-12         # Effective modal area in m^2
SoP_rotation = True   # Activate SoP rotation

G_edfa_dB = 26
NF_dB = 5
t, E_TX, E_carrier, s_tx, const_tx, s_b = DPQAM_transmitter(P_laser_TX,M = M, SpS = SpS, RollOff = RollOff, \
                ts = ts, sync_seed_X=0,sync_seed_Y=123,N_sync = 256,N_inf = N_inf,N_zeros_init=N_zeros_init,\
                N_zeros_final=N_zeros_final,ind_mod = ind_mod,Delta_nu=Delta_nu_TX,Freq_offset=Freq_offset_TX,\
                plot_flag = False)
# Visualization of the spectrum
spectrum_analysis(E_TX[0,:],t)

# Channel
E_amp = EDFA(E_TX,t,G_edfa_dB,NF_dB,lambda0=1550e-9)
E_RX = fiber(E_amp,t,L,DeltaL,D,lambda0,alpha_dB,n2,Aeff,SoP_rotation) # Output field

# Optical receiver
BER = DPQAM_receiver(E_RX,t,M,SpS,N_inf,RollOff,ts, s_b, P_laser = P_laser_RX,channel_id=1, Delta_nu = Delta_nu_RX, N_sync = N_sync, sync_seed_X=0,sync_seed_Y=123,
                         Freq_offset = Freq_offset_RX, \
                         plot_flag = True, BW=BaudRate*0.75, shot_noise = True, thermal_noise = True,L=L,D=D)
print('The BER of the Y component is:',BER[1])



"""Ex. 1: Modify the code in order to set the launched optical power (consider both polarizations)."""

plt.close('all')

plt.close('all')

# ========================
# General Parameters
# ========================
M = 16
SpS = 16
RollOff = 0.2
BaudRate = 56e9
Tsym = 1 / BaudRate
ts = Tsym / SpS
N_zeros_init = 100
N_sync = 256
N_inf = 2048
N_zeros_final = 100
sync_seed_X = 0
sync_seed_Y = 123

# ========================
# Optical System Parameters
# ========================
P_laser_TX = 0.01      # W
Delta_nu_TX = 0*100e3
P_laser_RX = 0.01      # W
Delta_nu_RX = 0*100e3
Freq_offset_TX = 0
Freq_offset_RX = 0
ind_mod = 0.1

L = 80e3
alpha_dB = 0.2e-3
D = 16e-6
n2 = 2.6e-20
DeltaL = 1e3
lambda0 = 1550e-9
Aeff = 80e-12
SoP_rotation = False
NF_dB = 5

# ========================
# Sweep Parameters
# ========================
P_dBm_array = np.arange(0, 13, 1)       # 0 a 12 dBm
P_W_array = 1e-3 * 10**(P_dBm_array/10) # conversão para W
BER_X = np.zeros(len(P_dBm_array))
BER_Y = np.zeros(len(P_dBm_array))

# ========================
# Sweep Loop
# ========================
for i, P_target in enumerate(P_W_array):

    print(f"\n=== Potência alvo: {P_dBm_array[i]:.1f} dBm ===")

    # Transmissor
    t, E_TX, E_carrier, s_tx, const_tx, s_b = DPQAM_transmitter(P_laser_TX,
        M=M, SpS=SpS, RollOff=RollOff, ts=ts,
        sync_seed_X=sync_seed_X, sync_seed_Y=sync_seed_Y,
        inf_seed_X=45, inf_seed_Y=46,
        N_sync=N_sync, N_inf=N_inf,
        N_zeros_init=N_zeros_init, N_zeros_final=N_zeros_final,
        ind_mod=ind_mod, Delta_nu=Delta_nu_TX, Freq_offset=Freq_offset_TX,
        plot_flag=False
    )

    # Calcula o ganho do EDFA necessário para atingir a potência alvo
    P_aux = np.mean(np.abs(E_TX[0,:])**2) + np.mean(np.abs(E_TX[1,:])**2)
    G_edfa_dB = 10 * np.log10(P_target / P_aux)
    #Poderiamos usar isso para ser das duas polarizações
    #P_aux = np.mean(np.abs(E_TX[0,:])**2)  # só uma polarização
    #G_edfa_dB = 10 * np.log10(P_target / P_aux)


    # Amplificação e transmissão
    E_amp = EDFA(E_TX, t, G_edfa_dB, NF_dB, lambda0=lambda0)
    E_RX = fiber(E_amp, t, L, DeltaL, D, lambda0, alpha_dB, n2, Aeff, SoP_rotation)

    # Recepção
    BER, const_rx = DPQAM_receiver(
        E_RX,t,M,SpS,N_inf,RollOff,ts, s_b,
        P_laser=P_laser_RX, Delta_nu=Delta_nu_RX,
        N_sync=N_sync, sync_seed_X=sync_seed_X, sync_seed_Y=sync_seed_Y,
        Freq_offset=Freq_offset_RX, plot_flag=False,
        BW=BaudRate*0.75, shot_noise=True, thermal_noise=True,
        L=L, D=D
    )

    # Armazena os BERs médios
    BER_X[i] = BER[0]
    BER_Y[i] = BER[1]

    print(f"BER_X = {BER[0]:.3e} | BER_Y = {BER[1]:.3e}")

# ========================
# Plot BER vs Potência
# ========================
plt.figure()
plt.semilogy(P_dBm_array, BER_X, 'o-', label='Polarização X')
plt.semilogy(P_dBm_array, BER_Y, 's-', label='Polarização Y')
plt.xlabel("Potência de Lançamento (dBm)")
plt.ylabel("BER")
plt.title("Curva BER × Potência de Lançamento (1 Canal DP-16QAM)")
plt.grid(True, which='both')
plt.legend()
plt.show()
